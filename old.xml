<rss version="2.0" data-livestyle-extension="available" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<channel>
<title>Caijinlin's blog</title>
<description>蔡金林的技术博客</description>
<link>/rss.xml</link>
<lastBuildDate>Tue, 07 Mar 2017 15:49:40 +0000</lastBuildDate>
<pubDate>Tue, 07 Mar 2017 15:49:40 +0000</pubDate>
<ttl>1800</ttl>
<item>
<title><![CDATA[php parse soap xml response]]></title>
<description>&lt;h3 id="php解析webservice-soap-xml-response">php解析webservice soap xml response&lt;/h3>&lt;!-- more -->&lt;p>####最近公司的一个需求，和外部对接需要用到xml。&lt;/p>&lt;blockquote>  &lt;p>说明：XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。&lt;/p>&lt;/blockquote>&lt;blockquote>  &lt;p>使用场景：请求外部webservie，对方以xml的形式的返回，我们需要拿到数据，看起来很简单，但不懂xml与xsd就有点麻烦了。&lt;/p>&lt;/blockquote>&lt;p>####遇到问题 =&amp;gt; 发现问题&lt;/p>&lt;blockquote>  &lt;p>通过传统解析xmlToJson, xmlToArray，怎么样也获取不到数据分析返回的xml，发现是xsd，并且含有命名空间The problem here is that your attribute has a namespace, so you need to register the ns with SimpleXML XPath and use it in your XPath query.&lt;/p>&lt;/blockquote>&lt;p>####解决方法&lt;/p>&lt;blockquote>  &lt;p>http://stackoverflow.com/questions/26511858/parsing-soap-xml-response-with-php/26512336#26512336&lt;/p>&lt;/blockquote>&lt;div class="language-xml highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="cp">&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;&lt;/span>&lt;span class="nt">&amp;lt;DATARESULT&lt;/span> &lt;span class="na">xmlns:xsi=&lt;/span>&lt;span class="s">"http://www.w3.org/2001/XMLSchema-instance"&lt;/span> &lt;span class="na">xmlns:xsd=&lt;/span>&lt;span class="s">"http://www.w3.org/2001/XMLSchema"&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">"http://tempuri.org/"&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>  &lt;span class="nt">&amp;lt;TABLE&amp;gt;&lt;/span>    &lt;span class="nt">&amp;lt;diffgr:diffgram&lt;/span> &lt;span class="na">xmlns:msdata=&lt;/span>&lt;span class="s">"urn:schemas-microsoft-com:xml-msdata"&lt;/span> &lt;span class="na">xmlns:diffgr=&lt;/span>&lt;span class="s">"urn:schemas-microsoft-com:xml-diffgram-v1"&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>      &lt;span class="nt">&amp;lt;DocumentElement&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">""&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>        &lt;span class="nt">&amp;lt;DATA&lt;/span> &lt;span class="na">diffgr:id=&lt;/span>&lt;span class="s">"TABLE1"&lt;/span> &lt;span class="na">msdata:rowOrder=&lt;/span>&lt;span class="s">"0"&lt;/span> &lt;span class="na">diffgr:hasChanges=&lt;/span>&lt;span class="s">"inserted"&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>          &lt;span class="nt">&amp;lt;FIED1&amp;gt;&lt;/span>1221&lt;span class="nt">&amp;lt;/FIED1&amp;gt;&lt;/span>          &lt;span class="nt">&amp;lt;FIED2&amp;gt;&lt;/span>2332&lt;span class="nt">&amp;lt;/FIED1&amp;gt;&lt;/span>        &lt;span class="nt">&amp;lt;/DATA&amp;gt;&lt;/span>             &lt;span class="nt">&amp;lt;DATA&lt;/span> &lt;span class="na">diffgr:id=&lt;/span>&lt;span class="s">"TABLE2"&lt;/span> &lt;span class="na">msdata:rowOrder=&lt;/span>&lt;span class="s">"0"&lt;/span> &lt;span class="na">diffgr:hasChanges=&lt;/span>&lt;span class="s">"inserted"&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>          &lt;span class="nt">&amp;lt;FIED1&amp;gt;&lt;/span>1221&lt;span class="nt">&amp;lt;/FIED1&amp;gt;&lt;/span>          &lt;span class="nt">&amp;lt;FIED2&amp;gt;&lt;/span>2332&lt;span class="nt">&amp;lt;/FIED1&amp;gt;&lt;/span>        &lt;span class="nt">&amp;lt;/DATA&amp;gt;&lt;/span>          &lt;span class="nt">&amp;lt;/DocumentElement&amp;gt;&lt;/span>    &lt;span class="nt">&amp;lt;/diffgr:diffgram&amp;gt;&lt;/span>  &lt;span class="nt">&amp;lt;/TABLE&amp;gt;&lt;/span>  &lt;span class="nt">&amp;lt;ResultMsg&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>&lt;span class="nt">&amp;lt;/DATARESULT&amp;gt;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注册命名空间，匹配相应节点，取出数据&lt;/p>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>// request webservice for get data$client = new SoapClient($url, $params);$result = $client-&amp;gt;getData();// parse data$xml = simplexml_load_string($result-&amp;gt;responseXml);$xml-&amp;gt;registerXPathNamespace('d', 'urn:schemas-microsoft-com:xml-diffgram-v1');$results = $xml-&amp;gt;xpath('//Table');&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2017-03/parse-soap-xml-response.html</link>
<guid>/php/2017-03/parse-soap-xml-response</guid>
<pubDate>Wed, 01 Mar 2017 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[vim快捷键]]></title>
<description>&lt;!-- more -->&lt;h3 id="移动">移动&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>h,j,k,l: 左下上右边ctrl+b/f：向上下翻页b/w: 上/下一个词$/0: 行首/尾(/): 上/下一个句子{/}: 段首/段尾gg/G: 文档开始/结束ngg: n行H/M/L: 屏幕顶端/中间/底部nj/k: 关标向上/下移动n行&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="选择">选择&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>v/V: 字符/行选中&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="编辑">编辑&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>i/a: 光标前/后插入I/A: 行首/尾插入o/O: 后/前插一行esc + o：另起一行编辑f/Fa: 光标移动到左/右边的第一个字符a上；dnb/w:  正/反向删除n个单词cnb/w:  正/反向删除n个单词cc: 修改光标所在行D: 删除到行尾rg: 替换光标下的字符为gx: 删除当前字母ddp: 调换当前行和下一行dd: 删除当前行，存入寄存器p: 粘贴yyp:复制当前行并粘贴u/ctrl+r: 撤销/重做&amp;gt;&amp;gt;/&amp;lt;&amp;lt;: 缩进/反缩进&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查找替换">查找替换&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>s/s1/s2: 将下一个s1替换为s2%s/s1/s2:全部替换s/s1/s2/g: 只替换当前行/string: 搜索下一处为n，搜索上一处为N&lt;/code>&lt;/pre>&lt;/div></description>
<link>/tool/2016-12/vim-hotkeys.html</link>
<guid>/tool/2016-12/vim-hotkeys</guid>
<pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[Sublime常用快捷键]]></title>
<description>&lt;h3 id="sublime常用快捷键整理">sublime常用快捷键整理&lt;/h3>&lt;!-- more -->&lt;ul>  &lt;li>mac下开启vim模式sublime =&amp;gt; preferences =&amp;gt; settings-user    &lt;div class="language-bash highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="s2">"ignored_packages"&lt;/span>：[],&lt;/code>&lt;/pre>    &lt;/div>  &lt;/li>  &lt;li>mac下使用shell以sublime方式打开文件：    &lt;div class="language-bash highlighter-rouge">&lt;pre class="highlight">&lt;code>ln -s &lt;span class="s2">"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl"&lt;/span> /usr/local/bin/sublsubl filename&lt;/code>&lt;/pre>    &lt;/div>  &lt;/li>&lt;/ul>&lt;h4 id="移动">移动&lt;/h4>&lt;div class="language-shell highlighter-rouge">&lt;pre class="highlight">&lt;code>h,j,k,l： 左，下，上，右。w：下一个词的词首。W：下一个单词&lt;span class="o">(&lt;/span>不含标点&lt;span class="o">)&lt;/span>。e：下一个词的词尾。E：不含标点。b：上一个词的词首。B：不含标点。gg：首。G： 尾。&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="选择">选择&lt;/h4>&lt;div class="language-shell highlighter-rouge">&lt;pre class="highlight">&lt;code>ctrl+d：选中下一个相同的ctrl+command+G：选中所有相同的ctrl+l：选中整行，继续操作则继续选择下一行，效果和 &lt;span class="nb">shift&lt;/span>+↓ 效果一样。ctrl+shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。&lt;span class="nb">shift&lt;/span>+↑：向上选中多行。&lt;span class="nb">shift&lt;/span>+↓：向下选中多行。&lt;span class="nb">shift&lt;/span>+←：向左选中文本。&lt;span class="nb">shift&lt;/span>+→：向右选中文本。&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="编辑">编辑&lt;/h4>&lt;div class="language-shell highlighter-rouge">&lt;pre class="highlight">&lt;code>ctrl+delete： 删除ctrl+shif+D：复制当前行ctrl+/：注释d当前行，或取消注释ctrl+J： 向上折行ctrl+K+U：转换大写ctrl+K+L： 转换小写ctrl+K+K：从光标处开始删除代码至行尾。ctrl+Z： 撤销ctrl+Y： 恢复撤销ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。ctrl+command+up： 向上移动当前行ctrl+command+down： 向下移动当前行&lt;span class="nb">shift&lt;/span>+home： 选择到页首行头&lt;span class="nb">shift&lt;/span>+end： 选择到页尾行Tab：向右缩进shfit+tab： 反缩进&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E5%B7%A5%E5%85%B7/2016-08/sublime-hotkeys.html</link>
<guid>/%E5%B7%A5%E5%85%B7/2016-08/sublime-hotkeys</guid>
<pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[node-sass 安装失败解决方法]]></title>
<description>&lt;h3 id="之前用npm安装速度也很慢">之前用npm安装速度也很慢&lt;/h3>&lt;!-- more -->&lt;p>####使用cnpm&lt;/p>&lt;div class="language-shell highlighter-rouge">&lt;pre class="highlight">&lt;code>	npm install -g cnpm&lt;/code>&lt;/pre>&lt;/div>&lt;p>####使用淘宝镜像&lt;/p>&lt;div class="language-shell highlighter-rouge">&lt;pre class="highlight">&lt;code>	&lt;span class="nv">SASS_BINARY_SITE&lt;/span>&lt;span class="o">=&lt;/span>https://npm.taobao.org/mirrors/node-sass/ npm install node-sass&lt;/code>&lt;/pre>&lt;/div></description>
<link>/node/2016-05/node-exlir.html</link>
<guid>/node/2016-05/node-exlir</guid>
<pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[mac高效工具配置]]></title>
<description>&lt;!-- more -->&lt;h3 id="vim语法高亮">vim语法高亮&lt;/h3>&lt;p>在vim中输入命令:syntax on激活语法高亮，若需要Vim启动时自动激活，在~/.vimrc中添加一行syntax on即可。&lt;/p>&lt;h3 id="iterm2--zsh">iterm2 + zsh&lt;/h3>&lt;p>step1.安装iterm2&lt;/p>&lt;p>&lt;a href="https://www.iterm2.com/">https://www.iterm2.com/&lt;/a>&lt;/p>&lt;p>step2.安装zsh, oh-my-zsh&lt;/p>&lt;p>&lt;a href="http://macshuo.com/?p=676">http://macshuo.com/?p=676&lt;/a>&lt;/p>&lt;p>step3.设置默认shell为zsh&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>chsh -s /bin/zsh&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="chrome-lastpass插件">chrome lastpass插件&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>记住网站密码，不用重复输入密码&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ssh免密码登录-参考">ssh免密码登录 &lt;a href="http://dhq.me/use-ssh-config-manage-ssh-session">参考&lt;/a>&lt;/h3>&lt;p>step1.生成密钥&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>ssh-keygen -t rsa -C "caijinlin2012@gmail.com"这里使用 rsa 的加密方式（另外一种加密方式是 dsa），中间会询问密钥生成的位置，这里只输入 cjb，在当前位置生成名为 cjb 的密钥，接着会询问是否要设置一个密码(passphrase)，这里留空，直接按回车就行（本来就不想登陆输入密码了...），最后，会在当前目录路径下生成一个名为 cjb 的私钥，一个名为cjb.pub 的公钥。&lt;/code>&lt;/pre>&lt;/div>&lt;p>step2.上传公钥到服务器 (如果方法一不行采用第二种)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>方法1.使用ssh-copy-id 	安装ssh-copy-id: curl -L https://raw.githubusercontent.com/beautifulcode/ssh-copy-id-for-OSX/master/install.sh | sh 	ssh-copy-id i ~/.ssh/cjl.pub root@182.92.5.70方法2.	把公钥 cjb.pub 上传到远程 cjb 服务器的 ~/.ssh/ 目录下：	scp cjl.pub root@182.92.5.70:~/.ssh/	上传完后，登录到服务器，把公钥 cjb.pub 的内容复制到 authorized_keys 文件里（不存在则新创建一个）：	cat cjb.pub &amp;gt;&amp;gt; authorized_keys&lt;/code>&lt;/pre>&lt;/div>&lt;p>step3. 加入配置文件&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>~/.ssh下新建配置文件config	Host        cjb	    HostName        216.194.70.6	    Port            22	    User            user	    IdentityFile    ~/.ssh/cjb  	Host        cjh	    HostName    182.92.5.70	    Port        22	    User        user&lt;/code>&lt;/pre>&lt;/div>&lt;p>step4. ssh cjh&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>	登录成功说明免密码登录成功了&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="sublime过滤文件夹搜索">sublime过滤文件夹搜索&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>sublime text =&amp;gt; Preferences =&amp;gt; Setting - User 加入配置，过滤文件夹和文件类型"folder_exclude_patterns": ["Runtime", "._d", ".metadata", ".settings"],"file_exclude_patterns": ["*.pyc", "*.pyo", ".project"]&lt;/code>&lt;/pre>&lt;/div></description>
<link>/tool/2016-04/mac-tool.html</link>
<guid>/tool/2016-04/mac-tool</guid>
<pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[php处理emoji表情]]></title>
<description>&lt;h3 id="php处理emoji表情">php处理emoji表情&lt;/h3>&lt;p>手机端网页输入表情时，显示的时候会乱码。而且android和iphone两种机型对emoji表情的解码不一样，导致一些不兼容问题。需要一种方案处理emoji表情，自己在做的时候，试了一下两种方案。&lt;/p>&lt;!-- more -->&lt;h4 id="三种方案">三种方案&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.使用utf8mb4存储（但不完美）2.使用现有的php-emoji库3.composer require mojione/emojione&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="方案一utf8mb4">方案一(utf8mb4)&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>修改编码, utf8mb4兼容utf8，且比utf8能表示更多的字符。可以存储emoji表情字符修改如下：1.设置表编码和相应字段编码为utf8mb42.设置连接数据库编码为utf8mb4ALTER TABLE `users` CHARACTER  SET utf8mb4 COLLATE utf8mb4_general_ci;ALTER TABLE `users` CHANGE `comment` `comment` TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL;DB_CHARSET =&amp;gt; 'utf8mb4'; //如果thinkphp，配置文件中修改连接数据库编码缺点: iphone手机上不能显示android手机发的表情优点:  简单，不用修改代码&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="方案二-httpsgithubcomiamcalphp-emoji">方案二 &lt;a href="https://github.com/iamcal/php-emoji">(https://github.com/iamcal/php-emoji)&lt;/a>&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>使用php-emoji库处理，原理是: 手机发的表情字符存入到数据库中是一段html, 显示的时候通过引用emoji库的css， 显示表情。修改如下:1.引入emoji.css, 并确保emoji.png引入到css中指定的位置2.引入emoji.php, post过来的内容作如下处理：$content = emoji_docomo_to_unified($content);$html = emoji_unified_to_html($content);//将$html存入数据库，$html类似&amp;lt;span class="emoji emoji1f609"&amp;gt;&amp;lt;/span&amp;gt;缺点: 通过css实现，需要加载emoji.css和emoji.png和emoji.php, 依赖外部优点: 兼容性好，web, android, iphone都可查看表情&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="方案三-httpspackagistorgpackagesemojioneemojione">方案三 &lt;a href="https://packagist.org/packages/emojione/emojione">(https://packagist.org/packages/emojione/emojione)&lt;/a>&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>通过composer引入: `composer require mojione/emojione`保存时: Emojione::toShort($comment));显示时: Emojione::shortnameToUnicode($comment);缺点：第三方输入法（比如百度输入法）的表情不是完全支持优点：目前为止兼容性最好的&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2016-03/php-emoji.html</link>
<guid>/php/2016-03/php-emoji</guid>
<pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[mysql开启慢查询日志]]></title>
<description>&lt;!-- more -->&lt;h4 id="登陆mysql客户端">登陆mysql客户端&lt;/h4>&lt;p>mysql -uroot -p123456&lt;/p>&lt;h4 id="开启检查">开启检查&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>show variables like 'slow_query_log';&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="相关配置">相关配置&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>show variables like '%log%';&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="开启">开启&lt;/h4>&lt;p>set global log_queries_not_using_indexes = on;&lt;/p>&lt;h4 id="时间">时间&lt;/h4>&lt;p>show variables like ‘long_query_time’;&lt;/p>&lt;h4 id="开启慢查询日志">开启慢查询日志&lt;/h4>&lt;p>set global slow_query_log = on;&lt;/p>&lt;h4 id="查找慢查询日志记录位置">查找慢查询日志记录位置&lt;/h4>&lt;p>show variables like ‘slow%’;&lt;/p>&lt;p>#mysqldumpslow -t 3 /usr/local/var/mysql/caijinlindeMBP-slow.log&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>log-slow-queries="/usr/local/val/log/mysql-slow.log"long_query_time = 4log-queries-not-using-indexes&lt;/code>&lt;/pre>&lt;/div></description>
<link>/mysql/2015-12/mysql-slow-query.html</link>
<guid>/mysql/2015-12/mysql-slow-query</guid>
<pubDate>Tue, 01 Dec 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[php-fpm监听进程不存在]]></title>
<description>&lt;h3 id="php-fpm启动">php-fpm启动&lt;/h3>&lt;p>基于lnmp安装的php-fpm启动后，发现并没有看到9000进程，加了网站配置文件后，出现502错误。&lt;/p>&lt;!-- more -->&lt;p>php-fpm可以正常启动，php-fpm默认在9000端口监听, 但是netstat并没有看到9000进程&lt;/p>&lt;h4 id="启动查找进程">启动查找进程&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    /etc/init.d/php-fpm start    netstat -anp | grep 9000&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看php-fpm配置文件">查看php-fpm配置文件&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    vim /usr/local/php/etc/php-fpm.conf    [global]    pid = /usr/local/php/var/run/php-fpm.pid    error_log = /usr/local/php/var/log/php-fpm.log    log_level = notice    [www]    listen = /tmp/php-cgi.sock  #监听，改成127.0.0.1:9000    listen.backlog = -1    listen.allowed_clients = 127.0.0.1    listen.owner = www    listen.group = www    listen.mode = 0666    user = www    group = www    pm = dynamic    pm.max_children = 10    pm.start_servers = 2    pm.min_spare_servers = 1    pm.max_spare_servers = 6    request_terminate_timeout = 100    request_slowlog_timeout = 0    slowlog = var/log/slow.log&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="网站配置文件testcomconf">网站配置文件test.com.conf&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    server {        listen 80;        server_name test.com;        index index.html index.shtml index.php;        root /home/wwwroot/default/test;        include /home/wwwroot/default/test/nginx_rewrite.conf;        location ~ .*\.(php|php5)?$        {            fastcgi_pass 127.0.0.1:9000; #9000端口            fastcgi_index index.php;            include fastcgi.conf;        }        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|woff)$        {            expires 30d;            access_log        off;            log_not_found     off;        }        location ~ .*\.(js|css)?$        {            expires 7d;            access_log        off;            log_not_found     off;        }        location ~ .*\.(htaccess)?$        {            deny all;        }    }&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="对比php-fpmconf与testcomconf发现php-fpm的监听和fastcgi_pass不太一样">对比php-fpm.conf与test.com.conf发现php-fpm的监听和fastcgi_pass不太一样&lt;/h3>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    两者需要将监听形式改成一样，比如都是127.0.0.1:9000或者/tmp/php-cgi.sock&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2015-11/php-fpm-502.html</link>
<guid>/php/2015-11/php-fpm-502</guid>
<pubDate>Wed, 18 Nov 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[php数组操作的坑]]></title>
<description>&lt;h3 id="掉进php数组操作的坑">掉进php数组操作的坑&lt;/h3>&lt;p>基于php数组操作，最近遇到两个坑，记录在这里&lt;/p>&lt;!-- more -->&lt;p>之前做一个搜索功能的时候，有一个需求是希望加一个“-”选项，以便可以取消搜索项&lt;/p>&lt;h4 id="第一次的做法">第一次的做法&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    $arr = array_merge(array(' ' =&amp;gt; "-"), $arr);&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>  &lt;p>&lt;a href="http://stackoverflow.com/questions/3292044/php-merge-two-arrays-while-keeping-keys-instead-of-reindexing">why not recommend array_merge&lt;/a>&lt;/p>&lt;/blockquote>&lt;p>隐患： array_merge合并时会重新索引，最后导致搜索的时候匹配失败&lt;/p>&lt;h4 id="第二次的做法">第二次的做法&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    $arr = array(' ' =&amp;gt; "-") + $arr;&lt;/code>&lt;/pre>&lt;/div>&lt;p>隐患: 如果$arr不是数组，就会发生意料的隐患&lt;/p>&lt;h4 id="最终做法">最终做法&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    settype($a, 'array');    $arr = array(' ' =&amp;gt; "-") + $arr;&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>&lt;p>小小的一个功能，如果不注意也会引发一些问题。&lt;/p></description>
<link>/php/2015-11/php-array-merge.html</link>
<guid>/php/2015-11/php-array-merge</guid>
<pubDate>Tue, 17 Nov 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[thinkphp的一些坑]]></title>
<description>&lt;h3 id="记录一下昨晚遇到的坑">记录一下昨晚遇到的坑&lt;/h3>&lt;p>在页面中使用加密函数加密id时，发现解密的时候不正确，原以为是加密函数或者解密函数的问题，但以前用的时候都没有问题，突然出现这个问题应该不是加密函数或者解密函数的问题。&lt;/p>&lt;!-- more -->&lt;h4 id="页面中是这样写的">页面中是这样写的&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    &lt;span class="nt">&amp;lt;a&lt;/span> &lt;span class="na">class=&lt;/span>&lt;span class="s">"btn btn-default"&lt;/span> &lt;span class="na">href=&lt;/span>&lt;span class="s">"__URL__/edit#!/{:encrypt_id($_one.id)}/step4"&lt;/span> &lt;span class="na">title=&lt;/span>&lt;span class="s">"查看"&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>        &lt;span class="nt">&amp;lt;i&lt;/span> &lt;span class="na">class=&lt;/span>&lt;span class="s">"gi gi-search"&lt;/span>&lt;span class="nt">&amp;gt;&amp;lt;/i&amp;gt;&lt;/span>&lt;span class="ni">&amp;amp;nbsp;&lt;/span>预览    &lt;span class="nt">&amp;lt;/a&amp;gt;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数据排查">数据排查&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    $_one.id也能读出数据&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="解决问题">解决问题&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>   页面中使用php时，函数中参数有 “.” 的话，thinkphp解析的时候加密错误，多么大的一个坑啊，改为$_one['id']就好&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2015-11/php-hollow.html</link>
<guid>/php/2015-11/php-hollow</guid>
<pubDate>Wed, 11 Nov 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[基于laravel构建npm,gulp,composer,bower]]></title>
<description>&lt;h3 id="gulp打造前端自动化工作流">gulp打造前端自动化工作流&lt;/h3>&lt;p>最近基于laravel框架，使用gulp构建前端自动化工作流, 提高开发效率， 记录一下， go !以下基于mac进行，其它环境使用相应的包管理工具安装。&lt;/p>&lt;!-- more -->&lt;h4 id="nodenpm安装">node,npm安装&lt;/h4>&lt;p>brew是mac下不错的包管理工具&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>brew install node . 该命令执行后，自动装好node和npm&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面的bower,gulp需要依赖node&lt;/p>&lt;p>####gulp安装&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>全局安装 npm isntall gulp -gcd 项目目录npm install --save-dev gulppackage.json包含了我们所需要的npm包， 建立package.jsonnpm install(生成文件在node_modules中)配置文件:gulpfile.js， 完成前端打包等工作&lt;/code>&lt;/pre>&lt;/div>&lt;p>####bower安装&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>全局安装 npm install bower -gcd 项目目录npm install --save-dev bower配置文件:bower.json包含了我们所需要的库文件, 建立bower.jsonbower install(生成文件在bower_components中)&lt;/code>&lt;/pre>&lt;/div>&lt;p>####composer安装&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>brew install composer配置文件:composer.json, 建立composer.jsoncomposer install(生成文件在vendor中)&lt;/code>&lt;/pre>&lt;/div>&lt;p>####package.json&lt;/p>&lt;p>所需要依赖的node包&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="p">{&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"repository"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{},&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"devDependencies"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"del"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^0.1.2"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^3.9.0"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-autoprefixer"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"0.0.10"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-concat"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^2.3.4"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-less"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^3.0.3"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-minify-css"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^0.3.7"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-rename"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^1.2.2"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-rev"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^1.1.0"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"gulp-uglify"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"^1.0.0"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"laravel-elixir"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"*"&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>####gulpfile.js&lt;/p>&lt;p>for example: 完成css,js压缩打包，加版本号等&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>var elixir = require('laravel-elixir');var gulp = require('gulp');var less = require('gulp-less');var autoprefixer = require('gulp-autoprefixer');var uglify = require('gulp-uglify');var concat = require('gulp-concat');var rev = require('gulp-rev');var del = require('del');var minifycss = require('gulp-minify-css');var rename = require('gulp-rename');/* |-------------------------------------------------------------------------- | Elixir Asset Management |-------------------------------------------------------------------------- | | Elixir provides a clean, fluent API for defining some basic Gulp tasks | for your Laravel application. By default, we are compiling the Less | file for our application, as well as publishing vendor resources. | */elixir(function(mix) {    mix.task(['build', 'watch']);});// CSS taskgulp.task('css', function() {    // Cleanup old assets    del(['public/build/css/*.css'], function (err) {});    // Convert scss first    gulp.src('resources/assets/less/*.less')        .pipe(less())        .pipe(autoprefixer('last 10 version'))        .pipe(concat('app.css'))        .pipe(minifycss())        .pipe(rename(function (path) {            path.basename += ".min"        }))        .pipe(rev())        .pipe(gulp.dest('public/build/css'));});// JavaScript taskgulp.task('js', function() {    // Cleanup old assets    del(['public/build/js/*.js'], function (err) {});    // Concat and uglify the JavaScript assets    // Afterwards add the MD5 hash to the filename    gulp.src('resources/assets/js/*.js')        .pipe(concat('app.js'))        .pipe(uglify())        .pipe(rename(function (path) {            path.basename += ".min"        }))        .pipe(rev())        .pipe(gulp.dest('public/build/js'));});//image taskgulp.task('copy:image', function () {  gulp.src('resources/images/**/*')    .pipe(gulp.dest('public/build/images'));});gulp.task('build', ['css', 'js', 'copy:image']);gulp.task('watch', function(){    gulp.watch('resources/assets/css/**/*.css', ['css']);    gulp.watch('resources/assets/js/**/*.js', ['js']);});// The default task (called when you run `gulp` from cli)// gulp.task('default', ['build', 'watch']);&lt;/code>&lt;/pre>&lt;/div>&lt;p>####bower.json&lt;/p>&lt;p>for example: 安装项目所需要的组件&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="p">{&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"name"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"laravel"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"version"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"1.0.0"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"authors"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="s2">"caijinlin &amp;lt;caijinlin2012@gmail.com&amp;gt;"&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"license"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"MIT"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"ignore"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="s2">"**/.*"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="s2">"node_modules"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="s2">"bower_components"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="s2">"test"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="s2">"tests"&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="nt">"dependencies"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"bootstrap"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"3.1.1"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"jquery"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"1.11.3"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"remarkable-bootstrap-notify"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"3.1.3"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"jquery_lazyload"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"~1.9.1"&lt;/span>&lt;span class="w">  &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>####composer.json&lt;/p>&lt;p>for example: 依赖laravel框架&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="p">{&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"name"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"laravel/laravel"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"description"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"The Laravel Framework."&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"keywords"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">"framework"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"laravel"&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"license"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"MIT"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"type"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"project"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"require"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"laravel/framework"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"5.0.*"&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"require-dev"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"phpunit/phpunit"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"~4.0"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"phpspec/phpspec"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"~2.1"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"barryvdh/laravel-debugbar"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"~2.0"&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"autoload"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"classmap"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"database"&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"psr-4"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="nt">"App\\"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"app/"&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"autoload-dev"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"classmap"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"tests/TestCase.php"&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"scripts"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"post-install-cmd"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"php artisan clear-compiled"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"php artisan optimize"&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"post-update-cmd"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"php artisan clear-compiled"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"php artisan optimize"&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"post-create-project-cmd"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"php -r \"copy('.env.example', '.env');\""&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">            &lt;/span>&lt;span class="s2">"php artisan key:generate"&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="nt">"config"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">        &lt;/span>&lt;span class="nt">"preferred-install"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"dist"&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E5%89%8D%E7%AB%AF/2015-10/npm-bower-gulp-composer.html</link>
<guid>/%E5%89%8D%E7%AB%AF/2015-10/npm-bower-gulp-composer</guid>
<pubDate>Sun, 25 Oct 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[redis read error on connection]]></title>
<description>&lt;h3 id="简单缓存服务scs">简单缓存服务SCS&lt;/h3>&lt;p>高性能、高可用的分布式缓存服务，兼容Memcache/Redis协议。&lt;/p>&lt;!-- more -->&lt;h4 id="使用scs中的redis时-遇到redis-read-error-on-connection的错误-经过一番搜索找到解决方法">使用SCS中的redis时, 遇到”redis read error on connection”的错误， 经过一番搜索找到解决方法。&lt;/h4>&lt;p>登录百度云后台，需将访问改集群的服务器设置为白名单&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>简单缓存服务SCS =&amp;gt; 集群名称 =&amp;gt; 添加白名单 =》 选择服务器&lt;/code>&lt;/pre>&lt;/div></description>
<link>/redis/2015-10/baidu-redis.html</link>
<guid>/redis/2015-10/baidu-redis</guid>
<pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[mysql不稳定排序]]></title>
<description>&lt;p>###mysql不稳定排序问题&lt;/p>&lt;p>mysql根据某一个字段排序，如果数据库中这个字段可能存在相同数值，仅仅通过该字段排序是不稳定的，如果加上了limit，可能会造成有一些结果没有显示，有些重复，这时候加上再id排序，才能得到正确地排序结果。&lt;/p>&lt;!-- more --></description>
<link>/mysql/2015-05/mysql-sort.html</link>
<guid>/mysql/2015-05/mysql-sort</guid>
<pubDate>Fri, 01 May 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[资源分享]]></title>
<description>&lt;h3 id="搜索技巧和资源整合">搜索技巧和资源整合&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>在这个信息爆炸的时代，我们如何用更短的时间获取到更有效的知识，我以前感到很苦恼。于是整理了一些关于知识整理和搜索技巧方面的东西(但是还是不够)。&lt;/code>&lt;/pre>&lt;/div>&lt;!-- more -->&lt;p>分享主题:搜索技巧和资源整合以及一些有用的工具及插件，网址.&lt;/p>&lt;p>分享ppt地址:&lt;a href="http://www.ipresst.com/play/5534b2e66309648f2a000af6">http://www.ipresst.com/play/5534b2e66309648f2a000af6&lt;/a>&lt;/p>&lt;p>以后若有更多内容，或关于生活，或关于技术，我将毫不吝啬地分享，希望能够有所帮助。最近多在翻墙，英语式的阅读，可以理解为装逼式地学习，成长中，感悟中.&lt;/p>&lt;p>reply:&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>            from 个人邮件: 　caijinlin2012@gmail.com            from 个人博客：　http://caijinlin.github.io            from 个人微信公众订阅号: susetips&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E9%9A%8F%E7%AC%94/2015-04/Search-source.html</link>
<guid>/%E9%9A%8F%E7%AC%94/2015-04/Search-source</guid>
<pubDate>Sun, 26 Apr 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[php like查询json字符串的某一个字段]]></title>
<description>&lt;!-- more -->&lt;h3 id="查询json字段需要过滤特殊字符-数据量大了之后可能存在性能问题">查询json字段需要过滤特殊字符, 数据量大了之后可能存在性能问题&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>比如donate_form_data存取 {	"name":"\u79d1\u5fe0",	"new_item_6":"\u7535\u5b50\u90ae\u7bb1",	"title":"这是一段描述",	"mobile":"",	"gender":"\u7537",	"new_item_1":"\u4e0d\u662f",	"new_item_2":"",	"new_item_3":"",	"new_item_4":"",	"new_item_5":"\u5426",	"address_widget_province":"",	"address":"",	"browser_user_agent":"Mozilla\/5.0 (Linux; U; Android 5.1.1; en-us; HUAWEI P7-L00 Build\/HuaweiP7-L00) AppleWebKit\/533.1 (KHTML, like Gecko)Version\/4.0 MQQBrowser\/5.4 TBS\/025440 Mobile Safari\/533.1 MicroMessenger\/6.2.5.50_rbb77fd6.621 NetType\/WIFI Language\/en",}需要查询donate_form_data 中的title 	$sql = "    SELECT         sum(cd.donate_amount) donate_amount, count(cd.donate_amount) donate_count    FROM         donates cd    WHERE         and cd.donate_form_data like '%s'    ";$query = '这是一段';$title = str_replace('\\', '_', json_encode($query));$donates[$item['id']] = M("")-&amp;gt;query($sql, '%' . $title . '%');&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2015-04/php-like-query.html</link>
<guid>/php/2015-04/php-like-query</guid>
<pubDate>Mon, 20 Apr 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[php细节整理]]></title>
<description>&lt;h3 id="php一些注意的点">php一些注意的点&lt;/h3>&lt;p>最近在php开发时，发现业务多了，经常会遇见因为php细节注意不当而导致的bug，影响开发效率，记录在这里。&lt;/p>&lt;!-- more -->&lt;p>php作为一种弱类型语言，所以强制类型转化有时就变得特别重要&lt;/p>&lt;h4 id="判断某个变量是否存在建议用isset即使a等于0也不会有问题">判断某个变量是否存在建议用isset,即使$a等于0也不会有问题&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    if (isset($a)) {            if ($a) {                        not=》    }                           }&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="define常量时判断一下">define常量时，判断一下&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    !defined('PROJECT_ID') &lt;span class="err">&amp;amp;&amp;amp;&lt;/span> defined('PROJECT_ID', 2);    如果PROJECT_ID没有定义时，输出PROJECT_ID ,则会打印出"PROJECT_ID"字符串，    所以使用的时候需要(int) PROJECT_ID判断下，是否存在。&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="不需要使用的变量尽量unset节约内存">不需要使用的变量，尽量unset，节约内存&lt;/h4>&lt;div class="language-php highlighter-rouge">&lt;pre class="highlight">&lt;code>    unset($a);&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="在某些情况下你可以使用isset-技巧加速执行你的代码">在某些情况下，你可以使用isset() 技巧加速执行你的代码。&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>（举例如下） if (strlen($foo) &amp;lt; 5) { echo 'Foo is too short'; } （与下面的技巧做比较） if (!isset($foo[5])) { echo 'Foo is too short'; } &lt;/code>&lt;/pre>&lt;/div>&lt;p>调用isset()恰巧比strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它的执行不需要函数查找和字母小写化。&lt;/p>&lt;h4 id="总结">总结&lt;/h4>&lt;p>很多php细节需要注意，一直在路上！&lt;/p></description>
<link>/php/2015-04/php-details.html</link>
<guid>/php/2015-04/php-details</guid>
<pubDate>Wed, 08 Apr 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[centos搭建reviewboard]]></title>
<description>&lt;h3 id="centos下搭建reviewboard">centos下搭建reviewboard&lt;/h3>&lt;!-- more -->&lt;h4 id="安装apachephpmysqlphpmyadminmemcache">安装apache,php,mysql,phpmyadmin,memcache&lt;/h4>&lt;p>yum install httpd  yum install php  yum -y install mysql-server  yum  -y install memcached  yum  -y install phpmyadmin  service memcached restart  /etc/init.d/mysqld restart  /etc/init.d/httpd restart  cp -R /usr/share/phpMyAdmin/ /var/www/html/  #find deny from all and comment it in the entire file  vim /etc/init.d/httpd/phpmyadmin.conf&lt;/p>&lt;h4 id="安装sendmail">安装sendmail&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>yum -y install sendmail&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="安装epel软件包">安装EPEL软件包&lt;/h4>&lt;p>wget http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm   sudo rpm -ivh epel-release-6-8.noarch.rpm&lt;/p>&lt;h4 id="安装reviewboard">安装reviewboard&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>yum -y install ReviewBoard&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数据库">数据库&lt;/h4>&lt;p>mysql -uroot -p123456;  create database reviewboard default charset utf8 collate utf8_general_ci;&lt;/p>&lt;h4 id="创建站点">创建站点&lt;/h4>&lt;p>rb-site install /var/www/reviewboard  #更改文件拥有者为apache（web服务器）（在site创建完成时，会提示做如下更改）  chown -R apache /var/www/reviewboard/htdocs/media/uploaded  chown -R apache /var/www/reviewboard/htdocs/media/ext/  chown -R apache /var/www/reviewboard/data/  #将reviewboard的配置文件拷贝到apache配置文件下  # cp /var/www/reviewboard/conf/apache-wsgi.conf /etc/httpd/conf.d&lt;/p>&lt;h4 id="重启apache">重启apache&lt;/h4>&lt;p>/etc/init.d/httpd restart&lt;/p>&lt;h4 id="reviewboard使用">reviewboard使用&lt;/h4>&lt;p>如果添加repo的时候出现错误permission denied accessing the local Git repository, 可能原因是git仓库地址的权限问题，改下权限就行，以便apache用户组也能访问&lt;/p></description>
<link>/%E5%B7%A5%E5%85%B7/2015-02/centos-reviewboard.html</link>
<guid>/%E5%B7%A5%E5%85%B7/2015-02/centos-reviewboard</guid>
<pubDate>Sun, 15 Feb 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[话题社区项目总结]]></title>
<description>&lt;h3 id="话题社区项目整体框架">话题社区项目整体框架&lt;/h3>&lt;p>在凤凰网实习期间和主管等4人做了一个项目，在春节期间上线。我主要负责后端，今天总结一下，写一下项目的历程和架构，以及一些收获。&lt;/p>&lt;!-- more -->&lt;h4 id="项目初期">项目初期&lt;/h4>&lt;p>接到产品需求后，项目主管审视了一番，觉得可以做。就开始规划话题社区的开展工作了，当时项目开发时间预估为20天。产品成果是嵌入到ios和anriod凤凰新闻客户端的.&lt;/p>&lt;h4 id="项目架构">项目架构：&lt;/h4>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/topicConfig.png" alt="项目配置" />&lt;/p>&lt;p>因为话题社区挂在访问量每天都在百万级别的凤凰希望新闻客户端上，所以必须需要足够的后台支持才行。&lt;/p>&lt;h4 id="项目准备">项目准备：&lt;/h4>&lt;p>为了做这个项目，我还专门学习了mongodb等相关知识。技术支持为php,javascript&lt;/p>&lt;h4 id="部分业务逻辑前端与客户端接口">部分业务逻辑(前端与客户端接口)&lt;/h4>&lt;ol>  &lt;li>在话题页面发表评论&lt;/li>&lt;/ol>&lt;p>（1）前端调用客户端接口，传入参数：   （2）用户发言、上传图片处理后将回调前端js方法，返回相关参数   （3）前端再将数据提交到后台&lt;/p>&lt;ol>  &lt;li>    &lt;p>在评论详情页面发表二级评论 （不支持发图片）&lt;br />2.1 回复评论&lt;/p>    &lt;p>（1）传给客户端的参数:（2）用户发言后,客户端将回调前端js方法，返回以下参数： (3） 前端将数据提交到后台&lt;/p>  &lt;/li>&lt;/ol>&lt;p>2.2 回复评论的评论&lt;/p>&lt;p>（1）传给客户端的参数:   （2）用户发言后,客户端将回调前端js方法，返回以下参数：   （3）前端将数据提交到后台&lt;/p>&lt;h4 id="收获">收获&lt;/h4>&lt;p>在这个项目开发的过程中，除了自身做了一些后台开发，也参与了一些手机客户端的测试工作，接触到了一些以前没接触的东西。&lt;/p></description>
<link>/php/2015-02/php-topic.html</link>
<guid>/php/2015-02/php-topic</guid>
<pubDate>Thu, 12 Feb 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[搭建git服务器]]></title>
<description>&lt;h3 id="centos搭建git服务器">centos搭建git服务器&lt;/h3>&lt;p>一些公司或者某些项目不适合放入github中，希望能有一个完全私有的仓库，如果有一台服务器，可以搭建git服务器，专门用于git服务。&lt;/p>&lt;!-- more -->&lt;h4 id="centos搭建git服务器-1">centos搭建git服务器&lt;/h4>&lt;p>step1. 安装git(如果没有就安装)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install git&lt;/code>&lt;/pre>&lt;/div>&lt;p>step2.创建一个git用户，用来运行git服务&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>groupadd gitadduser git -g gitpasswd git  /**设定密码*/&lt;/code>&lt;/pre>&lt;/div>&lt;p>step3.密钥管理&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。cd /home/git/mkdir .sshchmod 700 .sshtouch .ssh/authorized_keyschmod 600 .ssh/authorized_keys&lt;/code>&lt;/pre>&lt;/div>&lt;p>step4.初始化git仓库&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>cd /srvmkdir learngit.gitchown git:git learngit.gitgit init --bare learngit.git&lt;/code>&lt;/pre>&lt;/div>&lt;p>step5.客户端clone仓库&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>git clone git@192.168.45.4:/srv/learngit.git&lt;/code>&lt;/pre>&lt;/div>&lt;p>step6. 客户端push操作&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>cd learngittouch readme.txtgit add .git commit -m 'init'git push origin master&lt;/code>&lt;/pre>&lt;/div>&lt;p>【Notice】由于远程git服务器远程仓库里只是一个代码库，所以push代码到git服务器上，也看不到刚push过来的内容，这是正常的，可以进行pull等操作。&lt;/p></description>
<link>/git/2015-02/git-server.html</link>
<guid>/git/2015-02/git-server</guid>
<pubDate>Wed, 11 Feb 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[砸向自己的巨人坑（二）]]></title>
<description>&lt;h3 id="少敲代码多思考">少敲代码多思考&lt;/h3>&lt;!-- more -->&lt;h4 id="坑的来源">坑的来源&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.头脑发热，不知道ajax请求php文件时，php是通过echo返回值而不是return2.php作为弱类型的一门脚本语言，类型比较&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="开始挖坑">开始挖坑&lt;/h4>&lt;h4 id="业务逻辑">业务逻辑：&lt;/h4>&lt;p>修改密码时，一般都会要求输入原密码，检查原密码是否正确，检查正确才可以输入新密码修改密码；整个过程用ajax异步请求实现&lt;/p>&lt;h4 id="请求代码">请求代码：&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>$.get('/front/user/checkUserPwd/oldpassword/'+oldpassword, 				  function(data,status){			  		alert(data);//方便调试			  		if(parseInt(data)===parseInt(0)){ //没有比较类型			  			alert('密码错误');			  		}			  		else{			  			alert('密码正确');			  		}		  });&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="响应代码基于thinkphp">响应代码（基于Thinkphp）：&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>	$mailbox = $_SESSION[ C('ACCOUNT_AUTH_KEY')];	$password = md5($_GET['oldpassword']);	$condition['mailbox'] = $mailbox;	$condition['password'] = $password;	$account = M('Account');	$data = $account-&amp;gt;where($condition)-&amp;gt;select();	//var_dump($data);	//var_dump($password);	//return count($data);//最初我竟然是这样干的	echo count($data);&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现无论怎么输入正确还是错误的密码，data均为null，当我以为正确密码加密也不对的时候，我在响应代码中使用&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>	var_dump($data);	var_dump($password);&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现输入正确的密码，加密后匹配时是对的啊，此时发现data已经变成了数组内容，注意var_dump打印的就是类型和数据，相当于ajax请求已经结束，返回了值。当我使用var_dump(0),把它与数字0比较的时候，怎么比较都不对。使用echo就行，恍然大悟,php不同输出函数的特性。&lt;/p>&lt;p>但php是弱类型的语言，在匹配的时候，如果直接data===0，也会不成功，必须都转化为int时，才能使得类型和数值都得以匹配。&lt;/p>&lt;h4 id="总结">总结：&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.php与ajax交互时，ajax的返回值data是php使用打印函数打印出来的，而不是return的2.使用比较的时候注意php的弱类型&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2015-02/php-ajax.html</link>
<guid>/php/2015-02/php-ajax</guid>
<pubDate>Fri, 06 Feb 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[mongodb安装及使用(二)]]></title>
<description>&lt;p>###Windows下mongodb安装及使用&lt;/p>&lt;p>对于开发人员来说，安装环境应该是一件很简单的事情，可每次都搞得这么臃肿，关键在于没能理会其精华。如果你的阅历还不够，可能会有很多坑在等着你。今天在安装Mongodb的时候就遇到了用MongoVUE连接远程mongodb的坑。&lt;/p>&lt;!-- more -->&lt;p>上一篇文章讲述&lt;a href="http://caijinlin.github.io/php/2015-01/linux-mongodb.html" target="_blank">linux下mongodb安装及使用&lt;/a>，这一篇讲windows下Mongodb安装以及所遇到的坑。&lt;/p>&lt;p>step1.Download&lt;/p>&lt;p>&lt;a href="http://pan.baidu.com/s/1bnjKMkf">点击下载&lt;/a>&lt;/p>&lt;p>step2.Install&lt;/p>&lt;p>解压下载文件到D:\mongodb(比如)&lt;/p>&lt;p>step3.Start Server(在D:\mongodb下)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>mkdir datamkdir logscd binmongod --dbpath D:\mongodb\data  (启动服务器端)&lt;/code>&lt;/pre>&lt;/div>&lt;p>step4.Start Client(在D:\mongodb下)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>cd binmongoshow dbs;use admindb.addUser("root",123456)     //添加mongo用户，可以作为登录名db.auth("root",'123456');     //认证是否登录成功&lt;/code>&lt;/pre>&lt;/div>&lt;p>step5.Install Servicet(在D:\mongodb下)&lt;/p>&lt;p>每次开机运行都需要在（cmd）下面手动运行Mongodb,所以将Mongo数据库安装成为Windows服务.&lt;/p>&lt;p>D:\mongodb\bin&amp;gt;mongod –logpath D:\mongodb\logs\MongoDB.log –logappend –dbpath D:\mongodb\data –directoryperdb –serviceName MongoDB –install&lt;/p>&lt;font style="font:red">注意：必须为管理员权限， 否则无法创建服务&lt;/font>&lt;p>安装服务成功后：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>启动MongoDB：net start MongoDB停止MongoDB：net stop MongoDB删除MongoDB：sc delete MongoDB&lt;/code>&lt;/pre>&lt;/div>&lt;p>###安装MongoVUE&lt;/p>&lt;p>为了使mongodb可视化，安装Mongodb图形化管理工具,&lt;a href="http://pan.baidu.com/s/1hqpaxMk" target="_blank">点击下载Mongodb客户端&lt;/a>&lt;/p>&lt;font style="font:red">注意：连接时几个选项:&lt;/font>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Server：主机名或者ipPort：端口，一般为27017Username:当连本机时，可以不填；远程就填刚才在Mongo中创建的admin用户，不是计算机用户Password:当连本机时，可以不填；远程就填刚才在Mongo中创建的admin密码，不是计算机密码&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2015-01/windows-mongodb.html</link>
<guid>/php/2015-01/windows-mongodb</guid>
<pubDate>Mon, 12 Jan 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[Sublime下XDebug安装及使用]]></title>
<description>&lt;p>###Windows下安装及使用Sublime Text2/3 插件XDebug Client&lt;/p>&lt;p>sublime下配置xdebug,可以调试php程序，能够提高开发速度。今天花两个小时配置了xdebug，发现效率提升不少，更快地定位错误，提高解决问题的能力。以下是安装及使用步骤。&lt;/p>&lt;!-- more -->&lt;p>####安装步骤&lt;/p>&lt;p>step1.sublime 安装xdebug client&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>	ctrl+shift+p	install pacakage	xdebug client回车&lt;/code>&lt;/pre>&lt;/div>&lt;p>step2.配置php xdebug：找到标签[XDebug],添加如下内容&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>	xdebug.remote_enable = on	xdebug.remote_handler = "dbgp"	xdebug.remote_host = "127.0.0.1"	xdebug.remote_port = 9000 	zend_extension="D:\Program Files\phpStudy\php53\ext\xdebug.dll" //找到xdebug.dll的位置&lt;/code>&lt;/pre>&lt;/div>&lt;p>step3.配置sublime xdebug&lt;/p>&lt;p>点击sublime菜单栏的project-&amp;gt;save project as,保存后会当前工程生成一个.sublime-project的文件，修改为如下：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="p">{&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">"folders"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">	&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">		&lt;/span>&lt;span class="nt">"path"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"/D/WWW"&lt;/span>&lt;span class="w">	&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">"settings"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">	&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">	&lt;/span>&lt;span class="nt">"xdebug"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> 	&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">		&lt;/span>&lt;span class="nt">"path_mapping"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">	&lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> 		&lt;/span>&lt;span class="nt">"url"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">"http://127.0.0.1/topic/uploadpic.php"&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> 		&lt;/span>&lt;span class="nt">"super_globals"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">			&lt;/span>&lt;span class="nt">"close_on_stop"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">			&lt;/span>&lt;span class="nt">"port"&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">9000&lt;/span>&lt;span class="w"> 	&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">	 &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中url为你当前要调试的页面，你调试什么页面就改成该页面的地址&lt;/p>&lt;p>####使用步骤&lt;/p>&lt;p>step1.设置断点&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>在当前行代码标记：CTRL + F8&lt;/code>&lt;/pre>&lt;/div>&lt;p>step2.打开调试面板&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>ctrl+shift+p，然后输入Xdebug, 选择下拉的Xdebug:Start Debugging(Launch Browser),就会在浏览器中打开刚才的url.&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/sublime.png" alt="sublime" />&lt;/p>&lt;p>step3.开始调试(可以在调试的过程中监控某些值)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Ctrl+F8: 切换断点；Ctrl+Shift+F5: 运行到下一个断点；Ctrl+Shift+F6: 单步；Ctrl+Shift+F7: 步入；Ctrl+Shift+F8: 步出 Ctrl+Shift+F9: 开始调试 Ctrl+Shift+F10: 关闭调试&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/setwatch.png" alt="sublime" />&lt;/p></description>
<link>/%E5%B7%A5%E5%85%B7/2015-01/tools-sublime_xdebug.html</link>
<guid>/%E5%B7%A5%E5%85%B7/2015-01/tools-sublime_xdebug</guid>
<pubDate>Sat, 03 Jan 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[mongodb安装及使用]]></title>
<description>&lt;p>###linux下mongodb安装及使用&lt;/p>&lt;p>mongodb作为一种把数据存储在磁盘的非关系型数据库NOSql，具有一些关系数据库的特性，可以完成大部分sql语句的功能。并且MongoDB内置的水平扩展机制提供了从百万到十亿级别的数据量处理能力，存储的每一条记录可以看作是一个Document对象，并支持排序，得到了较好的应用。为了更好的学习，自己在linux下也动手配置mongodb了。&lt;/p>&lt;!-- more -->&lt;p>step1.download&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code> wget http://fastdl.mongodb.org/linux/mongodb-linux-i686-2.4.2.tgz&lt;/code>&lt;/pre>&lt;/div>&lt;p>step2.decompression&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code> tar -zxvf mongodb-linux-i686-2.4.2.tgz mkdir /usr/local/mongodb sudo mv -Rf mongodb-linux-i686-2.4.2/* /usr/local/monogodb&lt;/code>&lt;/pre>&lt;/div>&lt;p>step3.创建数据库和日志的存储目录：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code> mkdir -p /usr/local/mongodb/data mkdir -p /usr/local/mongodb/logs&lt;/code>&lt;/pre>&lt;/div>&lt;p>step4.修改mongodb的数据库和日志存储位置,并设置mongodb为后台启动&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>sudo /usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/logs/mongdb.log --fork&lt;/code>&lt;/pre>&lt;/div>&lt;p>step5.if the step4 has error like “error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory”&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>yum whatprovides libstdc++.so.6 yum install libstdc++-4.4.7-3.el6.i686(对应上一步出现的包名)&lt;/code>&lt;/pre>&lt;/div>&lt;p>step6.如果执行了step5,j就需要重新执行step4;否则不需要&lt;/p>&lt;p>step7.进入mongodb命令行模式&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>cd /usr/local/mongodb/bin./mongo&lt;/code>&lt;/pre>&lt;/div>&lt;p>step8.&lt;a href="http://www.111cn.net/sys/linux/58162.htm" target="_blank">开启php的Mongodb扩展&lt;/a> 就可以在php代码中使用Monggodb了&lt;/p>&lt;p>step9.全面学习Mongodb(&lt;a href="http://blog.csdn.net/yiqijinbu/article/details/9053467" target="_blank">http://blog.csdn.net/yiqijinbu/article/details/9053467&lt;/a>)&lt;/p></description>
<link>/php/2015-01/linux-mongodb.html</link>
<guid>/php/2015-01/linux-mongodb</guid>
<pubDate>Sat, 03 Jan 2015 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[ThinkPHP实现二级菜单]]></title>
<description>&lt;p>###thinkphp动态装载二级菜单&lt;/p>&lt;p>我们不使用任何php框架的时候，是可以很轻松实现两级菜单的。使用thinkphp时，需要嵌套使用循环并建立关联才能实现。&lt;/p>&lt;!-- more -->&lt;p>####数据库实体表category,字段为&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>categoryId, className, parentId分类id,     分类名称,  父类id&lt;/code>&lt;/pre>&lt;/div>&lt;p>####控制层IndexAction.class.php&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>function index(){	$m = M('category');	$list = $m-&amp;gt;where('parentId=0')-&amp;gt;select(); //获取一级菜单	foreach($list as $id =&amp;gt; $val){		$list[$id]['class']=$m-where('parentId='.$val['categoryId'])-&amp;gt;select();	}	$this-&amp;gt;assign('list',$list);	$this-&amp;gt;display();}&lt;/code>&lt;/pre>&lt;/div>&lt;p>####显示层输出显示index.html&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&amp;lt;volist name="list" io="l1"&amp;gt;	&amp;lt;ul&amp;gt;{$l1.className}&amp;lt;/ul&amp;gt;	&amp;lt;volist name="l1['class']" id="l2"&amp;gt;		&amp;lt;li&amp;gt;{$l2.className}&amp;lt;/li&amp;gt;	&amp;lt;/volist&amp;gt;&amp;lt;/volist&amp;gt;&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2014-12/php-thinkphp.html</link>
<guid>/php/2014-12/php-thinkphp</guid>
<pubDate>Tue, 30 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[Sublime JsFormat插件安装及使用]]></title>
<description>&lt;p>###安装及使用Sublime插件JsFormat&lt;/p>&lt;p>涉及到JSON格式数据的开发过程中，常常会为一长串未格式化的JSON数据而看的眼花，如下图所示，脑袋是不是大了Sublime JSON格式化。因此寻找一款格式化工具就来的非常必要。&lt;/p>&lt;!-- more -->&lt;p>####安装步骤&lt;/p>&lt;p>菜单栏Peferences -&amp;gt; Package Control -&amp;gt; install  -&amp;gt; jsFormat，回车安装&lt;/p>&lt;p>####使用&lt;/p>&lt;p>打开需要格式化的js文件，快捷键CTRL + ALT + f， 即可格式化。&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/JsFormat.png" alt="jsFormat插件格式化js代码" />&lt;/p></description>
<link>/%E5%B7%A5%E5%85%B7/2014-12/sublime-JsFormat.html</link>
<guid>/%E5%B7%A5%E5%85%B7/2014-12/sublime-JsFormat</guid>
<pubDate>Thu, 18 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[mysql主从复制配置]]></title>
<description>&lt;p>###mysql主从配置步骤&lt;/p>&lt;p>两台服务器的mysql版本一般规定为一致，这样可以避免一些乱七八糟的错误。建立基本的复制可以总结为一下三个简单步骤:&lt;/p>&lt;!-- more -->&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>step1.配置一个服务器为Master;step2.配置一个服务器作为Slave;step3.将slave连接到Master;&lt;/code>&lt;/pre>&lt;/div>&lt;p>为更好阐述，假设Master服务器为192.168.12.1,Slave服务器为192.168.12.2&lt;/p>&lt;p>####配置Master(在192.168.12.1机器上操作)&lt;/p>&lt;p>step1.添加配置选项(log-bi,log-bin-index,server-id)到mysql配置文件中&lt;/p>&lt;p>vi /etc/my.cnf&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>[mysqld]port            = 3306socket          = /tmp/mysql.sockdatadir = /usr/local/mysql/varskip-external-lockingkey_buffer_size = 16Mmax_allowed_packet = 1Mtable_open_cache = 64sort_buffer_size = 512Knet_buffer_length = 8Kread_buffer_size = 256Kread_rnd_buffer_size = 512Kmyisam_sort_buffer_size = 8Mlog-bin = master-binlog-bin-index = master-bin.indexserver-id = 1&lt;/code>&lt;/pre>&lt;/div>&lt;p>登陆到mysql后,命令show variables like ‘server%’可以看到服务器id是不是刚才写在配置文件的&lt;/p>&lt;p>step2.在Master创建一个复制用户&lt;/p>&lt;p>登陆到mysql后，执行以下命令(可自行设置新建用户名和密码)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>GREATE USER repl_user;GRANT REPLICATION SLAVE ON *.* TO repl_user@'192.168.12.2' IDENTIFED BY '123456';&lt;/code>&lt;/pre>&lt;/div>&lt;p>####配置Slave(在192.168.12.2机器上操作)&lt;/p>&lt;p>step1.添加配置选项(relay-log-index,relay-log,server-id)到mysql配置文件中 ,server_id与Master不同&lt;/p>&lt;p>vi /etc/my.cnf&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>[mysqld]port            = 3306socket          = /tmp/mysql.sockdatadir = /usr/local/mysql/varskip-external-lockingkey_buffer_size = 16Mmax_allowed_packet = 1Mtable_open_cache = 64sort_buffer_size = 512Knet_buffer_length = 8Kread_buffer_size = 256Kread_rnd_buffer_size = 512Kmyisam_sort_buffer_size = 8Mserver-id = 2relay-log-index = slave-relay-bin.indexrelay-log = slave-relay-bin&lt;/code>&lt;/pre>&lt;/div>&lt;p>####将slave连接到Master(在slave服务器192.168.12.2上操作)&lt;/p>&lt;p>登陆到mysql后执行：(MASTER_USER和MASTER_PASSWORD为之前在MASTER上面创建的用户和密码)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>CHANGE MASTER TO MASTER_HOST = '192.168.12.1', MASTER_PORT = 3306, MASTER_USER = 'repl_user', MASTER_PASSWORD = '123456'；&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后启动slave,检测是否配置成功&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>START SLAVE;SHOW SLAVE STAUS\G;&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果显示结果中，其中两项为yes,则配置成功&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Slave_IO_Running: YesSlave_SQL_Running: Yes&lt;/code>&lt;/pre>&lt;/div>&lt;p>####常见问题&lt;/p>&lt;p>我在配置的时候，并没有一次性成功。当我启动slave后，发现&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Slave_IO_Running: NoSlave_SQL_Running: Yes&lt;/code>&lt;/pre>&lt;/div>&lt;p>即从服务器IO线程没有启动，报错：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids&lt;/code>&lt;/pre>&lt;/div>&lt;p>####解决方法&lt;/p>&lt;p>这应该是比较常见的错误了，我slave上，登陆到mysql,执行show variables like ‘server%’命令发现从服务器的server_id 还是1，为什么没有改过来呢？&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>mysql&amp;gt; show variables like 'server%';mysql&amp;gt; find / -name "my.cnf";&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现当前目录下my.cnf有多处，可能是上一次安装残留文件&lt;/p>&lt;p>针对此种情形,进行全局设置,并停止slave后，再启动&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>mysql&amp;gt; set global server_id = 2;mysql&amp;gt; stop slave;mysql&amp;gt; start slave;mysql&amp;gt; show slave status\G;&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时问题解决，slave服务器Io和Sql线程均顺利启动&lt;/p>&lt;p>####总结&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>此时在主服务器运行 netstat -antlp | grep 3306, 发现本机和从服务器192.168.12.2都在监听192.168.12.1，主从复制配置顺利完成。&lt;/code>&lt;/pre>&lt;/div></description>
<link>/mysql/2014-12/mysql-slave.html</link>
<guid>/mysql/2014-12/mysql-slave</guid>
<pubDate>Thu, 18 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[轻松实现多台服务器数据库备份]]></title>
<description>&lt;p>####linux下两台服务器数据库导入导出&lt;/p>&lt;p>两台服务器环境均为lnmp(linux+nginx+mysql+php),今天一直想实现服务器A备份数据库test，并导入到服务器B中，传统的方法是通过linux共享实现的，具体可以参考&lt;a href="http://www.2cto.com/os/201108/102000.html" target="_blank">linux服务器共享&lt;/a>&lt;/p>&lt;!-- more -->&lt;p>####我的解决办法&lt;/p>&lt;p>充分利用lnmp环境，可以通过ip直接访问的特点，使用mysqldump备份A服务器数据库到网站根目录下，然后在服务器B中通过wget命令进行下载，最后使用mysql自带命令source导入B机数据库，其本质就是实现数据库同步。具体实现及常见问题解决办法如下：&lt;/p>&lt;p>假设A机ip为192.168.12.1 ,B机为192.168.12.2,，假设数据库用户和密码均为root将A机数据库test导入到B机数据库test，使用&lt;a href="http://pan.baidu.com/s/1eQ3qPf8" target="_blank">xshell软件&lt;/a>通过ssh协议连接两台linux服务器，方便操作.&lt;/p>&lt;p>####备份A机数据库test&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>cd www  /*切换到网站根目录*/mysqldump -uroot -proot test &amp;gt; test.sql&lt;/code>&lt;/pre>&lt;/div>&lt;p>####下载A机数据库test到B机&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>wget -c http://192.168.12.1/test.sql&lt;/code>&lt;/pre>&lt;/div>&lt;p>注：如果192.168.12.1的80端口没有打开，可能会出现一下错误：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>正在连接 192.168.12.1:80... 失败：没有到主机的路由&lt;/code>&lt;/pre>&lt;/div>&lt;p>排查错误：&lt;/p>&lt;p>定位A机，查看防火墙80端口是否对外开放&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/etc/init.d/iptables status  或者 service  iptables status;&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下情形没有打开80端口，3306和22端口是开放的&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/firewallPort.png" alt="防火墙设置" />&lt;/p>&lt;p>这时需要自行进行防火墙设置，可以开启80端口&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT #/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT/etc/init.d/iptables save&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了安全起见，我没有开启80端口，而是先关闭防火墙，让B机执行wget命令后，再开启防火墙&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/etc/init.d/iptables stop   (A机操作)&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，在B机执行命令，就没有问题了，下载的文件在当前目录&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>wget -c http://192.168.12.1/test.sql&lt;/code>&lt;/pre>&lt;/div>&lt;p>再回到A机，重新开启防火墙&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/etc/init.d/iptables restart &lt;/code>&lt;/pre>&lt;/div>&lt;p>####导入数据库到B机&lt;/p>&lt;p>在当前目录，登录到mysql后，使用source命令进行导入&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>mysql -uroot -proot;use test;source test.sql;&lt;/code>&lt;/pre>&lt;/div></description>
<link>/linux/2014-12/linux-share.html</link>
<guid>/linux/2014-12/linux-share</guid>
<pubDate>Thu, 18 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[砸向自己的巨人坑]]></title>
<description>&lt;p>###不要乱写注释&lt;/p>&lt;p>为了体现自己的专业，在写代码的时候，我会尽量写注释。可是今天却被自己写的注释整整坑了6个小时。当php注释风格遭遇html注释风格的时候，我想很少有像我这样的逗逼掉进了陷阱吧。&lt;/p>&lt;!-- more -->&lt;p>####坑的来源(注释风格迥异)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>php注释风格： // 单行注释 ; /**/ 多行注释html注释风格：&amp;lt;!-- --&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>####开始挖坑&lt;/p>&lt;p>今天我在写一个ajax异步请求的时候，主要是测试一段代码。&lt;/p>&lt;p>业务逻辑很简单： 入口页面填写用户名和密码，点击注册按钮，触发引入js文件中的ajax的异步请求，向远程数据库插入数据。&lt;/p>&lt;p>连接数据库连接部分还是一如既往写了一个类，还写了4行注释，现在来看，这样来连数据库绝对是菜鸟。由于这4行不在&lt;?php ?>标签内，所以是&lt;b>&amp;lt;color=”red”&amp;gt;html注释&amp;lt;/color&amp;gt;&lt;/b>。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&amp;lt;!--	数据库类	author:caijl	date:2014/12/17;--&amp;gt;&amp;lt;?php	class ConnectionMySQL{				//主机		private $host="localhost";				//数据库用户		private $name = "root";		//数据库服务器密码		private $password = "root";		//数据库名称		private $database = ""; 		//连接		private $conn ="";		//构造函数		function __construct($host, $name, $password, $database){			$this-&amp;gt;host = $host;			$this-&amp;gt;name = $name;			$this-&amp;gt;password = $password;			$this-&amp;gt;database = $database;			$this-&amp;gt;connect();		}		//连接函数		function connect()		{			$this-&amp;gt;conn = mysql_connect($this-&amp;gt;host, $this-&amp;gt;name, $this-&amp;gt;password);			mysql_select_db($this-&amp;gt;database);			mysql_query("set names utf8");		}		//处理函数		function query($sql)		{			return mysql_query($sql);		}        //关闭连接		function close()		{			mysql_close();		}		//获取连接		function getDb()		{			return $this-&amp;gt;conn;		}	}	?&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>在处理请求的文件中，我是这样处理来自入口页面的请求的&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&amp;lt;?php  require("conn.php");  header('Content-type: text/html; charset=utf8');  //$user_info = json_encode($_POST);  $user_name = json_encode($_POST["name"]);   $user_pwd =  json_encode($_POST["pwd"]);  $db = new ConnectionMySQL("192.168.25.108","root","123456","test");  $sql = "insert into user_info(user_name, user_pwd) values($user_name, $user_pwd)";  $result = $db-&amp;gt;query($sql);  echo json_encode($result);?&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>报错结果： object xmlHttprequest ,但是数据插入到数据库中了，相当纳闷。&lt;/p>&lt;p>####爬出坑&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>为了解决这个问题,我用了echo,var_dump函数进行输出测试，但都石沉大海。不甘心就此结局。 搬来google浏览器自带调试工具，开始学习ajax调试。看到&amp;lt;a href="http://www.cnblogs.com/mybest/archive/2011/12/13/2285730.html" style="color:red;"&amp;gt;Jquery.Ajax之错误调试帮助信息&amp;lt;/a&amp;gt;，开始了 疯狂的调试之旅。在js文件中设置断点还不够，对错误信息进行全面分析。 ![Jquery.Ajax请求](http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/JqueryAjax.png)&lt;/code>&lt;/pre>&lt;/div>&lt;p>单步调试一番后，错误详情为parseerror.难道是返回数据类型不是json,看下图&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/parseerror.png" alt="json数据错误" />&lt;/p>&lt;p>终于找到错误:&lt;b> &amp;lt;color=”red”&amp;gt;Invalid Json&amp;lt;/color&amp;gt;&lt;/b>&lt;/p>&lt;p>竟然还有我在数据库连接类中的注释信息？难道注释不起作用了？&lt;/p>&lt;p>####脱离坑&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>原来是在类文件中，前四行是作为html注释，引入到处理请求的文件中，由于该段内容在php标签内，所以注释格式应该是/* */,看到此番注释，php当然不识别。&lt;/code>&lt;/pre>&lt;/div>&lt;p>####总结&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>之所以遇到坑，就是还太嫩了。不过收获的是：更加会利用google浏览器调试一些信息。&lt;/code>&lt;/pre>&lt;/div></description>
<link>/php/2014-12/php-note.html</link>
<guid>/php/2014-12/php-note</guid>
<pubDate>Wed, 17 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[lnmp环境及navicat配置安装]]></title>
<description>&lt;p>###lnmp环境安装及解决遇到的问题&lt;/p>&lt;p>今天搭建了2台linux服务器lnmp环境，安装的过程中也是遇到一些问题。总结一下：如果nginx，mysql，php安装了多次，即使卸载，但是进程仍然在运行，所以每次重新安装的时候，最好kill掉原进程。在解决问题的过程中，还学了一些平时没怎么用的linux命令，算是另外的收获吧，折腾一天也值了。&lt;/p>&lt;!-- more -->&lt;p>####shell命令一键安装lnmp：&lt;/p>&lt;p>CentOS系统下执行：wget -c http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz &amp;amp;&amp;amp; tar zxf lnmp1.1-full.tar.gz &amp;amp;&amp;amp; cd lnmp1.1-full &amp;amp;&amp;amp; ./centos.sh&lt;/p>&lt;p>Debian系统下执行：wget -c http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz &amp;amp;&amp;amp; tar zxf lnmp1.1-full.tar.gz &amp;amp;&amp;amp; cd lnmp1.1-full &amp;amp;&amp;amp; ./debian.sh&lt;/p>&lt;p>Ubuntu系统下执行：wget -c http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz &amp;amp;&amp;amp; tar zxf lnmp1.1-full.tar.gz &amp;amp;&amp;amp; cd lnmp1.1-full &amp;amp;&amp;amp; ./ubuntu.sh&lt;/p>&lt;p>更多了解访问&lt;a href="http://lnmp.org/install.html" target="_blank">lnmp官网&lt;/a>&lt;/p>&lt;p>测试lnmp安装是否成功：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>service nginx status;service mysql status;&lt;/code>&lt;/pre>&lt;/div>&lt;p>####navicat软件下载(数据库管理软件,可以连接远程数据库)&lt;/p>&lt;p>&lt;a href="http://pan.baidu.com/s/1qW6uj5y" target="">点击下载&lt;/a>&lt;/p>&lt;p>####遇到的问题&lt;/p>&lt;h4 id="1mysql-unknown-os-character-set-gb18030">1.mysql: Unknown OS character set ‘GB18030’.&lt;/h4>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code> mysql: Switching to the default character set 'latin1'.&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题所在：操作系统编码问题&lt;/p>&lt;p>解决方案：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>step1.更改操作系统字符集(shell命令)	vim /etc/sysconfig/i18n   将LANG="zh_CN.GB18030"改成LANG="zh_CN.UTF-8"step2.设置环境变量(shell命令)	exoport LANG = "zh_CN.UTF-8"step3.立刻生效环境更改	source /etc/profile&lt;/code>&lt;/pre>&lt;/div>&lt;p>####2.mysql登录&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>mysql -u root p123456   &amp;lt;!-- 假设root为数据库用户名，123456为数据库密码--&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>####3.使用数据库管理工具navicat连接远程数据库出现无法连接的问题&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Linkerror.png" alt="远程连接错误" />&lt;/p>&lt;p>排查错误：&lt;/p>&lt;p>1.远程服务器端口3306是否打开&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>step1:客户机上 telnet ipAddress 3306，看服务器的3306端口是否被打开&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/mysqlport.png" alt="mysql port" />&lt;/p>&lt;p>2.远程服务器是否不允许从远程登陆&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>运行shell命令：netstat -an | grep 3306如果上图红色部分为127.0.0.1，则说明只能本机访问，不被允许远程访问&lt;/code>&lt;/pre>&lt;/div>&lt;p>解决方案：登录服务器mysql，设置允许客户机192.168.30.105以用户root,密码root登陆&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.30.105' IDENTIFIED BY 'root' WITH GRANT OPTION;&lt;/code>&lt;/pre>&lt;/div></description>
<link>/linux/2014-12/linux-lnmp.html</link>
<guid>/linux/2014-12/linux-lnmp</guid>
<pubDate>Tue, 16 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[MYSQL存储引擎]]></title>
<description>&lt;p>###MYSQL两种最常用的存储引擎&lt;/p>&lt;p>InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。&lt;/p>&lt;!-- more -->&lt;p>####主要区别&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.InnoDB不支持FULLTEXT类型的索引。2.InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。package，搜索ctags就能找到ctags的插件，安装之。4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。tags文件，那么这个时候就可以定位函数了。(具体参考&amp;lt;a href="https://github.com/SublimeText/CTags#additional-setup-steps" target="_blank"&amp;gt;官方API&amp;lt;/a&amp;gt;)&lt;/code>&lt;/pre>&lt;/div>&lt;p>####应用场景一般规则&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.应用程序要使用事务时必须采用InnoDB引擎2.应用程序对查询性能要求较高，就要使用MYISAM了。MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。&lt;/code>&lt;/pre>&lt;/div></description>
<link>/mysql/2014-12/mysql-storage.html</link>
<guid>/mysql/2014-12/mysql-storage</guid>
<pubDate>Mon, 15 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[学习新技术]]></title>
<description>&lt;p>###如何快速学习一门新技术?&lt;/p>&lt;p>此文主要写给和我弟弟一样非计算机专业想学习编程的人，都是个人参考各位大牛给出的意见整理的一些意见。本人能力还有限，写出来的东西写得可能肤浅，但可能让他们受益，这就够了。&lt;/p>&lt;!-- more -->&lt;p>####学习技术的路线&lt;/p>&lt;p>每个人只要努力，都可以学会一门技术，只是时间和效率的问题。关于如何学习一门技术，初学者会带着很多疑问，很多时候由于环境配置打击了学习我们技术的激情。&lt;/p>&lt;p>所以对于一般的编程环境，我们采取集成环境一键安装，这样能够快速上手，我们不需要过分关心软件用什么方式安装的，软件只是工具，我们只要知道如何利用工具达到我们的目的，这就够了。当然自己有能力了，感兴趣的话可以再去研究。&lt;/p>&lt;p>学习成长过程就好比如下一张图，懂得把握技术特点并充分利用其技术特点做一些不同的事情的人更知道活学活用，这或许才是最重要的吧。&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/learn.png" alt="学习技术" />&lt;/p></description>
<link>/%E9%9A%8F%E7%AC%94/2014-12/Essay-technology.html</link>
<guid>/%E9%9A%8F%E7%AC%94/2014-12/Essay-technology</guid>
<pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[Sublime函数跳转插件Ctags安装及使用]]></title>
<description>&lt;p>###Windows下安装及使用Sublime Text2/3 插件Ctags&lt;/p>&lt;p>sublime确实是一款非常不错的开发软件，用起来很爽，里面集成了很多插件，只要安装即可，介绍下sublime中ctags插件的安装，安装这个插件之后就可以快速定位某函数了，非常方便。&lt;/p>&lt;!-- more -->&lt;p>####安装步骤&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.下载并解压(http://pan.baidu.com/s/1o6umSjg)ctags包&amp;lt;/a&amp;gt;中的ctags.exe到系统环境路径（默认压缩在c:\windows\system32就好了） 2.若没安装package control在这个插件的话，先安装它。3.现在安装开始ctags的插件了，在package control中选择install package，搜索ctags就能找到ctags的插件，安装之。4.然后在项目目录下右键选择“Ctags:Rebuild Tags” ，就生成了.tags文件，那么这个时候就可以定位函数了。(具体参考https://github.com/SublimeText/CTags#additional-setup-steps)官方API&amp;lt;/a&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>####使用步骤&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.跳转进入：ctrl+t, ctrl+t2.退出返回：ctrl+t, ctrl+b&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E5%B7%A5%E5%85%B7/2014-12/tootls-sublime_tags.html</link>
<guid>/%E5%B7%A5%E5%85%B7/2014-12/tootls-sublime_tags</guid>
<pubDate>Thu, 11 Dec 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[ajax同步和异步问题]]></title>
<description>&lt;p>ajax同步和异步问题&lt;/p>&lt;p>今天在写写js代码的时候遇到AJAX加载数据都需要考虑代码运行顺序问题。最近的项目用了到AJAX同步。这个同步的意思是当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，当这个AJAX执行完毕后才会继续运行ajax后面的其他代码（相当于单线程，代码顺序执行），页面假死状态解除。&lt;/p>&lt;!-- more -->&lt;p>而异步则这个AJAX代码运行中的时候，ajax后面其他代码一样可以同时运行，相当于多线程（线程之间同步执行，线程内部顺序执行）。&lt;/p>&lt;p>jquery的async:false,这个属性 默认是true：异步，false：同步。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>$.ajax({       type: "post",       url: "path",       cache:false,       async:false,       dataType: "json",       success: function(data){ } });&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里，async默认的设置值为true，这种情况为异步方式，就是说当ajax发送请求后，在等待server端返回的这个过程中，前台会继续 执行ajax块后面的脚本，直到server端返回正确的结果才会去执行success，也就是说这时候执行的是两个线程，ajax块发出请求后一个线程 和ajax块后面的脚本（另一个线程）例：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>$.ajax({    type:"POST",   url:"del.aspx",   dataType:"html",   success:function(result){   //function1()  f1();   f2();   }  failure:function (result) {     alert('Failed');    },} function2(); &lt;/code>&lt;/pre>&lt;/div>&lt;p>在上例中，当ajax块发出请求后，他将停留function1()等待server端的返回，但同时（在这个等待过程中），前台会去执行function2(),也就是说，在这个时候出现两个线程，我们这里暂且说为function1() 和function2()。&lt;/p>&lt;p>当把asyn设为false时，这时ajax的请求时同步的，也就是说，这个时候ajax块发出请求后，他会等待在function1（）这个地方，不会去执行function2()，知道function1()部分执行完毕&lt;/p>&lt;p>####总结:如果ajax块请求对后面代码无影响时，可用异步；如果ajax块请求对后面代码有影响，或者存在数据交换，可用同步&lt;/p></description>
<link>/%E7%BC%96%E7%A8%8B/2014-11/program-ajax.html</link>
<guid>/%E7%BC%96%E7%A8%8B/2014-11/program-ajax</guid>
<pubDate>Tue, 04 Nov 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[TargetInvocationException异常]]></title>
<description>&lt;h3 id="未处理targetinvocationexception调用的目标发生了异常">未处理TargetInvocationException，调用的目标发生了异常&lt;/h3>&lt;p>今天在使用数据库表实体类映射的时候，出现TargetInvocationException错误，单步调试也没能找出问题来源。&lt;/p>&lt;p>后面才知道因为版本的原因，类名发生冲突，导致实例化的类并没用调用到相应的构造函数，导致接收数据失败。&lt;/p>&lt;!-- more -->&lt;p>写在博客上，以防后面再出这样的错误：&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/voteresult.png" alt="蔡金林的博客" />&lt;/p>&lt;p>重命名类名后，可以发现实例化后的对象，具有与数据库字段相匹配的属性：&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/votebug.png" alt="蔡金林的博客" />&lt;/p></description>
<link>/%E7%BC%96%E7%A8%8B/2014-10/program-bug.html</link>
<guid>/%E7%BC%96%E7%A8%8B/2014-10/program-bug</guid>
<pubDate>Fri, 31 Oct 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[快速排序代码总结]]></title>
<description>&lt;h3 id="快速排序">快速排序&lt;/h3>&lt;h4 id="快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分其中一部分的所有数据都比另外一部分的所有数据都要小然后再按此方法对这两部分数据分别进行快速排序整个排序过程可以递归进行以此达到整个数据变成有序序列">快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/h4>&lt;!-- more -->&lt;p>####不需要枢轴的快排流程图（最简单的一种）&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/quicksort.png" alt="蔡金林的博客" />&lt;/p>&lt;p>####快速排序&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/*快速排序思想:分治法*/class Mysort{    public:    void output(int *a, int n)    {        int loop = 0;        for(;loop&amp;lt;n;loop++)        {            cout&amp;lt;&amp;lt;a[loop]&amp;lt;&amp;lt;" ";        }        cout&amp;lt;&amp;lt;endl;    }    void swap(int *m, int *n)    {        int temp;        temp = *m;        *m = *n;        *n = temp;    }    /*分组*/    int  partition(int *a, int left, int right)    {        /*设置为key=a[right]*/        int i=left-1, p = right;//设置枢轴，也可以设置p=right;        int j = left;        int key = a[p];        for(;j&amp;lt;right;j++)        {            if(a[j]&amp;lt;=key)            {                i++;//移动位置                swap(&amp;amp;a[i],&amp;amp;a[j]);            }        }        swap(&amp;amp;a[p],&amp;amp;a[i+1]);        return i+1;        /*设置枢轴，也可以设置p=left;        int i=left, p = left;        int j = left+1;        int key = a[p];        for(;j&amp;lt;right;j++)        {            if(a[j]&amp;lt;=key)            {                i++;//移动位置                swap(&amp;amp;a[i],&amp;amp;a[j]);            }        }        swap(&amp;amp;a[p],&amp;amp;a[i]);        return i;        */    }    /*元素个数快速*/    void quicksort1(int *a, int n) //数组，元素个数    {        int left = 0;        int right = n-1;        if(n&amp;lt;=1)        {            return ;        }        while(left&amp;lt;right)        {            while(a[left]&amp;lt;a[right]&amp;amp;&amp;amp;left&amp;lt;right)            {                left++;            }            swap(&amp;amp;a[left],&amp;amp;a[right]);            while(a[right]&amp;gt;a[left]&amp;amp;&amp;amp;left&amp;lt;right)            {                right--;            }            swap(&amp;amp;a[left],&amp;amp;a[right]);        }        quicksort1(a,left);        quicksort1(a+left+1,n-left-1);//参数为元素个数时，指针需要移动    }    /*下标快速*/    void quicksort2(int *a, int left, int right)    {        if(left&amp;lt;right)        {             while(left&amp;lt;right)             {                while(a[left]&amp;lt;a[right]&amp;amp;&amp;amp;left&amp;lt;right)                {                    left++;                }                swap(&amp;amp;a[left],&amp;amp;a[right]);                while(a[right]&amp;gt;a[left]&amp;amp;&amp;amp;left&amp;lt;right)                {                    right--;                }                swap(&amp;amp;a[left],&amp;amp;a[right]);            }            quicksort2(a,0,left-1);            quicksort2(a,left+1,right);//参数为下标，指针不需要移动        }    }    /*分组快排*/    void quicksort3(int *a, int left, int right)    {        int q = 0;        if(left&amp;lt;right)        {            q = partition(a,left,right);            quicksort3(a,left,q-1);            quicksort3(a,q+1,right);        }    }    /*以中间值作为枢纽进行快排*/    void quicksort4(int *a, int left,  int right)    {        int mid, i, j;        if(left&amp;lt;right)        {                mid = (left+right)/2;                i=left-1;                j=right+1;                while(1)                {                    while(a[++i]&amp;lt;a[mid]);                    while(a[--j]&amp;gt;a[mid]);                    if(i&amp;gt;=j)                    {                    	break;                    }                    swap(&amp;amp;a[i],&amp;amp;a[j]);                }                quicksort4(a,left,i-1);                quicksort4(a,j+1,right);        }    }};&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-08/quicksort-Algorithm.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-08/quicksort-Algorithm</guid>
<pubDate>Sun, 17 Aug 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[快速找到段错误的core方法]]></title>
<description>&lt;h3 id="段错误">段错误&lt;/h3>&lt;p>####段错误一般表现为段吐核，随着程序的运行，如果边界考虑不全，非法引用了无效成员等，会导致此种情况&lt;/p>&lt;!-- more -->&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/*段吐核问题解决演示*/#include &amp;lt;stdio.h&amp;gt;typedef struct stu{    int age;    char sex;}STU;int main(){    STU *stu1=NULL;    printf("%d\n",stu1-&amp;gt;age);    return 0;}&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/error.png" alt="蔡金林的博客" />&lt;/p>&lt;p>####解决方法&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.ulimit -c unlimited  (解除生成核心转储信息文件的大小限制)2.gcc test.c -g (加入-g选项生成调试信息)3. ./a.out(有段错误，就会出现core文件)4.gdb ./a.out -c core (gdb调试)5.在gdb调试命令行下输入bt(back trace),它会显示出现错误的地方&lt;/code>&lt;/pre>&lt;/div></description>
<link>/linux/2014-08/linux-Core.html</link>
<guid>/linux/2014-08/linux-Core</guid>
<pubDate>Fri, 15 Aug 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[计算机内存分配方式]]></title>
<description>&lt;h3 id="内存分配">内存分配&lt;/h3>&lt;p>####计算机内存可以从静态存储区，常量存储区，堆，栈分配，分别存储对应的变量&lt;/p>&lt;!-- more -->&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/neicun.png" alt="蔡金林的博客" />&lt;/p></description>
<link>/linux/2014-08/linux-memory.html</link>
<guid>/linux/2014-08/linux-memory</guid>
<pubDate>Thu, 14 Aug 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[2048游戏c语言算法实现]]></title>
<description>&lt;h3 id="2048游戏">2048游戏&lt;/h3>&lt;p>玩儿过这款游戏后，小编才知道什么叫“根本停不下来”。在4X4的棋盘上，每次会增加一个数字，你可以选择四个方向，然后数字会按方向移动，遇到相同的数字就会合并，游戏的目的就是合并出2048这个数字，最终看你获得了多少总分。2048也就是2的11次方，即合并11次。原本1024就已经不容易了，升级到2048，一旦停下来就还真的不好完成了！像小编这种数学是体育老师教的，看着这款好玩到爆的游戏只能一声长叹，两行清泪划过脸颊。&lt;/p>&lt;!-- more -->&lt;p>判断输赢：表格填满数字且无法通过移动来合并数字时，游戏退出&lt;/p>&lt;p>源代码实现c算法版：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>/*    2048游戏*/#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;memory.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;time.h&amp;gt;#define MAX 4int row=0,col=0;//元素下标int loop=0;//排数int i = 0, j = 0;//下标int map[MAX][MAX] = {0};/*初始化数组*/void init(){    memset(map,0,sizeof(map));}/*在某一个空的位置创建随机数*/void CreateRandNumber(){    int flag =0,pos=0;    srand(time(0));    int x =0 ,y = 0;    int r[MAX*MAX];    int c[MAX*MAX];    int k = 0;    /*判断哪些位置可空*/    for(row=0;row&amp;lt;MAX;row++)    {        for(col=0;col&amp;lt;MAX;col++)        {            if(map[row][col]==0)            {                r[k]=row;                c[k]=col;                k++;            }        }    }    if(k==0)    {        printf("游戏结束\n");        exit(0);    }    printf("\n");    pos = rand()%k;    x = r[pos];    y = c[pos];    map[x][y] = (rand()%2+1)*2;    printf("产生随机数map[%d][%d]=%d\n",x,y,map[x][y]);    /*从空的位置中产生一个随机数2或者4*/}/*显示游戏盘*/void show_map(){    CreateRandNumber();    for(row=0;row&amp;lt;4;row++)    {        for(loop=0;loop&amp;lt;4;loop++)        {            printf("----+");        }        printf("\n");        for(col=0;col&amp;lt;4;col++)        {            if(map[row][col]==0)            {                printf("    |");            }            else            {                 printf("%-4d|",map[row][col]);            }        }        printf("\n");    }    for(loop=0;loop&amp;lt;4;loop++)    {        printf("----+");    }    printf("\n");}/*向左移动*/void toward_left(){    printf("正在向左移动\n");    for(loop=0;loop&amp;lt;4;loop++)    {        //移动数字        for(i=1;i&amp;lt;=3;i++)        {            for(j=i;j&amp;gt;0;j--)            {                if(map[loop][j-1]==0)                {                    map[loop][j-1]=map[loop][j];                    map[loop][j]=0;                }            }        }        //合并相同数字        for(i=1;i&amp;lt;=3;i++)        {            if((map[loop][i]==map[loop][i-1]) &amp;amp;&amp;amp; (map[loop][i-1]!=0))            {                map[loop][i-1]=2*map[loop][i-1];                map[loop][i]=0;            }        }    }}/*向上移动*/void toward_up(){    printf("正在向上移动\n");    for(loop=0;loop&amp;lt;4;loop++)    {        //移动数字        for(i=1;i&amp;lt;=3;i++)        {            for(j=i;j&amp;gt;0;j--)            {                if(map[j-1][loop]==0)                {                    map[j-1][loop]=map[j][loop];                    map[j][loop]=0;                }            }        }        //合并相同数字        for(i=1;i&amp;lt;=3;i++)        {            if((map[i-1][loop]==map[i][loop]) &amp;amp;&amp;amp; (map[i-1][loop]!=0))            {                map[i-1][loop]*=2;                map[i][loop]=0;            }        }    }}/*向下移动*/void toward_down(){    printf("正在向下移动\n");    for(loop=0;loop&amp;lt;4;loop++)    {        //移动数字        for(i=3;i&amp;gt;0;i--)        {            for(j=i;j&amp;lt;=3;j++)            {                if(map[j][loop]==0)                {                    map[j][loop]=map[j-1][loop];                    map[j-1][loop]=0;                }            }        }        //合并相同数字        for(i=3;i&amp;gt;0;i--)        {            if((map[i][loop]==map[i-1][loop]) &amp;amp;&amp;amp; (map[i][loop]!=0))            {                map[i][loop]*=2;                map[i-1][loop]=0;            }        }    }}/*向右移动*/void toward_right(){    printf("正在向右移动\n");    for(loop=0;loop&amp;lt;4;loop++)//四排    {        //移动数字        i = 2;        while(i&amp;gt;=0)        {            for(j=i;j&amp;lt;3;j++)            {                if(map[loop][j+1]==0)                {                    map[loop][j+1]=map[loop][j];                    map[loop][j]=0;                }            }            i--;        }        //合并相同数字        for(i=2;i&amp;gt;=0;i--)        {            if((map[loop][i+1]==map[loop][i]) &amp;amp;&amp;amp; (map[loop][i+1]!=0))            {                map[loop][i+1]=2*map[loop][i+1];                map[loop][i]=0;            }        }    }}/*开始游戏*/void play(){    show_map();    char direction = ' ';    while(1)    {        printf("h代表向左，j代表向向上，k代表向下，l代表向右:\n");        printf("输入方向：");        scanf("%c",&amp;amp;direction);        scanf("%*[^\n]");        scanf("%*c");        switch(direction)        {            case 'h':toward_left(); show_map();break;            case 'j':toward_up(); show_map();break;            case 'k':toward_down(); show_map();break;            case 'l':toward_right(); show_map();break;            default:break;        }    }}int main(){    init();    play();    return 0;}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E6%B8%B8%E6%88%8F/2014-08/Game-2048.html</link>
<guid>/%E6%B8%B8%E6%88%8F/2014-08/Game-2048</guid>
<pubDate>Wed, 13 Aug 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[五子棋c语言算法实现]]></title>
<description>&lt;h3 id="五子棋">五子棋&lt;/h3>&lt;p>五子棋是一种两人对弈的纯策略型汉族棋类益智游戏，棋具与围棋通用，由中国古代汉族人发明，起源于中国上古时代的传统黑白棋种之一。主要流行于华人和汉字文化圈的国家以及欧美一些地区。容易上手，老少皆宜，而且趣味横生，引人入胜&lt;/p>&lt;!-- more -->&lt;p>判断输赢：以某一点为中心向四周4个方向判断，连续数达到5个即取胜&lt;/p>&lt;p>源代码实现c算法版：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;stdio.h&amp;gt;#include&amp;lt;memory.h&amp;gt;#define size 10 //棋盘大小char map[size][size]= {};int row = 0,col = 0;/*初始化棋盘数组*/void init(){    memset(map,' ',sizeof(map));}/*显示棋盘*/void showmap(){    int loop=0,row=0,col=0;    for(loop=0;loop&amp;lt;size;loop++)    {        printf("%4d",loop+1);    }    printf("\n");    for(row=0;row&amp;lt;size;row++)    {        printf("  ");        for(loop=0;loop&amp;lt;size;loop++)        {            printf("---+");        }        printf("\n");        printf("%2d|",row+1);        for(col=0;col&amp;lt;size;col++)        {            printf("%c | ",map[row][col]);        }        printf("\n");    }    printf("  ");    for(loop=0;loop&amp;lt;size;loop++)    {        printf("---+");    }    printf("\n");}/*判断输赢,胜利则返回玩胜利玩家*/char judge(int x, int y, char player){int count=0;//记录是否组成五子棋/*东北和西南方向判断开始*//*向右上45度(东北方向)判断*/row = x-1;col = y+1;while((row&amp;gt;=0)&amp;amp;&amp;amp;(col&amp;lt;=size-1)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    row--;    col++;}/*向左下45度(西南方向)判断*/row = x+1;col = y-1;while((row&amp;lt;=size-1)&amp;amp;&amp;amp;(col&amp;gt;=0)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    row++;    col--;}if(count+1==5){    return player;}/*东北和西南方向判断结束*//*西北和东南方向方向判断开始*//*向左上45度(西北方向)判断*/count = 0;row = x-1;col = y-1;while((row&amp;gt;=0)&amp;amp;&amp;amp;(col&amp;gt;=0)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    row--;    col--;}/*向右下45度(东南方向)判断*/row = x+1;col = y+1;while((row&amp;lt;=size-1)&amp;amp;&amp;amp;(col&amp;lt;=size-1)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    row++;    col++;}if(count+1==5){    return player;}/*西北和东南方向判断结束*//*竖直方向方向判断开始*//*竖直向上判断*/count = 0;row = x-1;col = y;while((row&amp;gt;=0)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    row--;}/*竖直向下判断*/row = x+1;col = y;while((row&amp;lt;=size-1)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    row++;}if(count+1==5){    return player;}/*竖直方向判断结束*//*水平方向判断*//*水平向左判读*/count = 0;row = x;col = y-1;while(col&amp;gt;=0){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    col--;}/*水平向右判断*/row = x;col = y+1;while((col&amp;lt;=size-1)){    if(map[row][col]==player)    {        count++;    }    else    {        break;    }    col++;}if(count+1==5){    return player;}/*水平方向判断结束*/return '0';//没有形成五子棋时}/*下棋*/void chess(){char player = 'A';//玩家char winner = '0';//赢家while(winner=='0'){do{     printf("玩家%c要下棋的位置坐标:",player);     scanf("%d,%d",&amp;amp;row,&amp;amp;col);     printf("坐标为:%d,%d\n",row,col);     printf("%s",(map[row-1][col-1]!=' ')?"输入无效,请重新输入\n":"输入正确\n");}while(map[row-1][col-1]!=' ');map[row-1][col-1]=player;showmap();winner = judge(row-1,col-1,player);//玩家下棋后，马上进行判断输赢player = (player=='A')?'B':'A';//切换玩家}printf("游戏结束，玩家%c赢\n",winner);}int main(){init();     /*初始化棋盘位置元素值*/showmap(); /*第一次显示棋盘*/chess();  /*开始下棋*/}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E6%B8%B8%E6%88%8F/2014-08/Game-chess.html</link>
<guid>/%E6%B8%B8%E6%88%8F/2014-08/Game-chess</guid>
<pubDate>Tue, 12 Aug 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[我的数模之路]]></title>
<description>&lt;h3 id="两年数模暑期培训过程">﻿两年数模暑期培训过程&lt;/h3>&lt;p>我参加过两年的数学建模暑期器培训，虽然也取得过一些还不错的奖，但还不至于能够有资格评论数学建模暑期培训过程。写这篇文章的目的是希望把自己在数学建模的经历写出来，后来的学弟学妹看到后能够有所收获。&lt;/p>&lt;!-- more -->&lt;p>####第一次暑期培训前&lt;/p>&lt;p>大一的暑假，七月底我就来到学校了，和所有准备参加数模暑期培训的同学一样，迎接一个月艰苦的培训过程。来的那天，协会就召开了数模暑期集结会议，来的人差不多90个了。开完会后所有没有组队的同学都留下来了，这里面就有我，那时候我还只是很普通的一名会员，也不认识多少人。但我庆幸的是，没组队的人里面有一个我老乡的朋友桃子，之前就见过几面，桃子也没组队，于是我们一拍即合，决定组成一队，共战数模，此时我们队就我和他，还却一个人，我们又不认识别人，协会干部说后面会给我们再安排一个人。那天晚上，我们一起去汇北吃了晚饭，聊了一会儿，就散去。&lt;/p>&lt;p>####第一次暑期培训中&lt;/p>&lt;p>一个月的数学建模暑期培训就开始了，第一天一来到机房，找到位置，发现我们被安排在最后一排，同样在最后一排还有当时的会长组。每一天都是上午老师讲课，下午上机，晚上还是上机。那时的我们根本不敢偷玩，因为感觉那时后面有眼睛看着我们。第一周，我们两个人一起吃饭，一起学习，虽然我们都是搞编程的，没有搞建模的，也没有搞论文的，但那时我们互相安慰自己，我们两个人既可以搞编程又可以搞建模，后面只要再来一个搞论文的就行。所以于是乎，我们都分担了更多的责任，那时我和桃子也不喜欢说话，给人的感觉还是比较安静，也很普通。印象深刻的是，我和桃子在协会的第一次自我介绍，因为ppt做得不错，可能一些人已经记住了普通的我们，但会经常把我们两个人的名字记反。那一周以来，别人中午休息的时候，我们不休息，听会儿歌，看会儿好声音,继续学习。我和他很多地方相似，总会有相见一顾的感觉，有时都会忍不住对笑。培训过了一周了，可我们组还是我和桃子两个人，所以我和他两个人完成了第一次模拟赛,熬了两个通宵，都编程，都写论文，都建模，这样的组合可能是比较少见的。第一次模拟赛结束后，我们拿了个第一名，当时真的很兴奋。当时我们还被安排讲解我们的论文，此时，我们进入了大众的视线，协会为我们安排的队友也来了。是一个妹子，毫无疑问，她主要负责写论文。我和桃子都是属于比较不太会说话，也不太爱说话，所以很少与她沟通，但我们吃饭还是在一起，有时也会觉得有些尴尬。但后来慢慢都习惯了，就这样我们三个人一起组合，度过了第二次模拟赛，第三次模拟赛，每次模拟赛，我和桃子都熬了差不多两个通宵。我们在建模的时候，会把自己的思路和方法写下来，整理后再传给她。三次模拟赛我们都取得了不错的成绩，这个暑期培训过得很充实，没有很多杂质，确实学到了一些东西。到了国赛的时候，最艰难的时刻到了，第二天女队友就生病了，要打针。所以就只剩下我和桃子并肩作战了，三天我们几乎没有合眼过，因为时间真的很有限，我们要承担所有的任务。虽然女队友打完针后，会过来一下，但我和桃子都知道，我们并不能指望她能够做些什么，我们只能安慰她病早点好。就这样，我们还是很艰难地完成第一次国赛。&lt;/p>&lt;p>####第一次答辩&lt;/p>&lt;p>国赛过去了几天，有一天晚上睡得特别晚，大概是凌晨3点多，刚睡下，就接到老大的电话，告诉我们组后天要去成都答辩，当时那个兴奋啊，简直睡不着睡觉，由于太晚，我决定第二天再告诉队友这个好消息。第二天要答辩的队伍被叫到机房作准备，相当于答辩前的预热，当时要每个队要选一个主辩手，我想要么就是我要么就是桃子，我觉得自己不会表达，就建议桃子去当主辩。就这样愉快地决定了，这一天我们熟悉了我们的论文，并打印了一些要点。第三天就去成都答辩了，早上在校门口集合的时候，桃子说他嗓子有点不舒服，我说没影响只要说出来就好了。去答辩的队伍中，只有我们这个队伍是大一的，还有些骄傲。去答辩的那天，我们起得特别早，中午就到成都了。在成都吃了一顿丰盛的午餐，吃完饭后歇了会儿，就去答辩。我们队是我们学校第一支答辩的队伍，当时很紧张，但还是硬着头皮上了。我们进去答辩了，下面的老师问了很多问题，有两个问题没有表达好，觉得不太好。出来后，才知道我们已进去差不多30分钟，所有人都很诧异，一般进去答辩的队伍时间都会低于15分钟，我们心里仿佛已经知道了什么，所有队伍答辩完后，合影后，回学校。当时已经是下午5点了。回来的时候车子在眉山停了，我们又在那吃了一顿大餐。吃完后，继续奔向回学校的路上，后面气氛似乎不太对，好像成绩已经出来了，但始终没有公布。我和桃子都仿佛意识到了什么，到学校的时候已经是晚上10点多了。回到寝室后，接到了桃子的电话，他告诉我我们组的国奖资格被取消了，原因是被怀疑是抄袭。&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/shumo.png" alt="蔡金林的博客之数模之路" />&lt;/p>&lt;p>我们当时就很无语，我们也想过找老师，但是根本就没有用。在接下来的一周多，我们都很不爽，郁闷沮丧，有些自暴自弃了，协会的干部也找了我们，作我们的心理工作。随着时间慢慢推移，我们只能无奈地接受这个结果。第一次暑期培训就这样结束了。&lt;/p>&lt;p>####第二次暑期培训前&lt;/p>&lt;p>那个暑假我没有回家，7月份在学校练车，8月份就参加了第二次暑期培训。8月初，我和桃子再聚首，那个女队友没参加了，我们依然面临分组问题，当时也是在召开暑期培训集结大会的时候，有一个干部也没有组队，他就是后来的小三（男）。小三想和我们组队，我和桃子就答应了，就这样我，桃子，小三征战第二次暑期培训了。&lt;/p>&lt;p>####第二次暑期培训中&lt;/p>&lt;p>第二次与第一次暑期培训最大的不同在于，我们三个都是干部，成为了协会当时的骨干。当然心态也变得不一样了，上午面对老师上课，我们基本都会坐在最后面，我们没有听老师讲课，但我们会带本书，学习新的算法。下午我们会给他们布置一些作业，晚上给他们批改作业，任务量变大了，但却能收获到不少东西。自从和小三组队后，我和桃子性情大变，一切都变得非常有趣。我们的那个机房，有一组学长很不矜持，堪比逗比，没错，那就是我们三人。但说实话，我们学习的时候还是很认真，我觉得心态很重要，我是个自我调节能力相当强的人，秉承着开心就好的理念，奋战第二次数模。或许由于我这个特点，我成为了小大了，桃子成为了小二了，桃园三结义似乎在数模上演了。周围的人似乎有被我们感染到，我们为何总是那么开心，看上去是那么傻逼。三次模拟赛，我们却三夺第一，这不能不说是奇迹。这个暑期培训感觉过得特别快，也是我大学生涯中最开心的时候。从来没有那么开心，我和桃子原来不太爱开玩笑，自从遇到了三，性情大变，喜欢互相调侃，称对方为傻逼。又到了国赛，我和桃子知道那对我们意味着什么，心里都高兴不起来了，神经一刻都不敢放松。三天三夜，我们又熬过来了，几乎没有睡几个小时。&lt;/p>&lt;p>####第二次答辩&lt;/p>&lt;p>过了几天，情况还算乐观，我们又可以去成都答辩了。这次我成为主辩手，去之前理了个发，当时还调侃说，上次没理发，这次理个发再去。很幸运的是，这次通过答辩，我们也拿到了全国一等奖，那一刻，我和桃子相互拥抱，我们一起风风雨雨走过了两年，患难与共。我们终于没有遗憾了。第二次暑期培训圆满结束。&lt;/p>&lt;p>####结语&lt;/p>&lt;p>我不知道看到这篇文章的学弟学妹，会作何感想，我希望你们能够好好珍惜暑期培训的时光，真的很宝贵，该学习的时候加倍学习，该放松的时候好好放松。“海鸥不再眷念大海，可以飞更远”是我现在比较喜欢的一句话，我把它送给你们，希望你们能够在数模有所收获，取得佳绩。当然大学不仅仅有数学建模，其它方面也要有所突破。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>																		数学建模小大  2014-08-11&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E9%9A%8F%E7%AC%94/2014-08/Essay-shumo.html</link>
<guid>/%E9%9A%8F%E7%AC%94/2014-08/Essay-shumo</guid>
<pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[内部排序算法分析]]></title>
<description>&lt;h3 id="内部排序算法插入排序归并排序选择排序冒泡排序快速排序">内部排序算法（插入排序,归并排序,选择排序,冒泡排序,快速排序）&lt;/h3>&lt;p>####排序简介&lt;/p>&lt;p>排序是数据处理中经常使用的一种重要运算,在计算机及其应用系统中,花费在排序上的时间在系统运行时间中占有很大比重;并且排序本身对推动算法分析的发展也起很大作用。目前已有上百种排序方法，但尚未有一个最理想的尽如人意的方法，本章介绍常用的如下排序方法，并对它们进行分析和比较。&lt;/p>&lt;!-- more -->&lt;p>####排序分类&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1、插入排序（直接插入排序、折半插入排序、希尔排序）；2、交换排序（起泡排序、快速排序）；3、选择排序（直接选择排序、堆排序）；4、归并排序；5、基数排序；&lt;/code>&lt;/pre>&lt;/div>&lt;p>####排序时间复杂度&lt;/p>&lt;p>1.插入类排序&lt;/p>&lt;p>将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度&lt;/p>&lt;p>2.交换类排序&lt;/p>&lt;p>通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。&lt;/p>&lt;p>3.选择类排序&lt;/p>&lt;p>从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。&lt;/p>&lt;p>4.归并排序&lt;/p>&lt;p>通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度。&lt;/p>&lt;p>5.基数排序&lt;/p>&lt;p>一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也不只是使用于整数。&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/timecomplexity.png" alt="蔡金林的博客之时间复杂度" />&lt;/p>&lt;p>####一、插入排序&lt;/p>&lt;p>直接插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>void InsertSort(int L[],int length)  {      int i,j;//分别为有序区和无序区指针      for(i=1;i&amp;lt;length;i++)//逐步扩大有序区      {          j=i+1;          if(L[j]&amp;lt;L[i])          {           L[0]=L[j];//存储待排序元素           While(L[0]&amp;lt;L[i])//查找在有序区中的插入位置，同时移动元素           {          L[i+1]=L[i];//移动          i--;//查找           }          L[i+1]=L[0];//将元素插入      }     i=j-1;//还原有序区指针  }  &lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/InsertSort.png" alt="插入排序" />&lt;/p>&lt;p>####二、交换排序&lt;/p>&lt;p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>void BubbleSort(int a[], int n){    int i,j;    for(j=0;j&amp;lt;=n-1;j++)      {        for(i=0;i&amp;lt;=n-1-j;i++)        {          if(a[i]&amp;gt;a[i+1])//数组元素大小按升序排列          {             temp=a[i];             a[i]=a[i+1];             a[i+1]=temp;          }        }    }}  &lt;/code>&lt;/pre>&lt;/div>&lt;p>快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：运用分治法,通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分小。分别对两部分排序，然后递归进行。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>int Partition(int a[], int low, int high){    int temp = a[row];    while(low&amp;lt;high)    {      while(low&amp;lt;high &amp;amp;&amp;amp; a[high] &amp;gt;= temp) high--;      a[low] = a[high];      while(low&amp;lt;high &amp;amp;&amp;amp; a[low] &amp;lt;= temp) low++;      a[high] = a[low];    }    a[low] = temp;}void Quick_sort(int a[],int low ,int high){    if(low &amp;lt; high)    {      i=Partition(a,low,high);      Quick_sort(a,low,i-1);      Quick_sort(a,i+1,high);    }}&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/QuickSort.png" alt="快速排序" />&lt;/p>&lt;p>####三、选择排序&lt;/p>&lt;p>直接选择排序(Selection sort)是一种简单直观的排序算法。原理是将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>void SelectSort(int a[], int n){  for(i=0;i&amp;lt;n-1;i++)    {      k = i;      for(j=i+1;j&amp;lt;n;j++)      {          if(a[k] &amp;gt; a[j])          k = j;      }      if(k != i)      {          temp = a[i];          a[i] = a[k];          a[k] = temp;      }    }  }&lt;/code>&lt;/pre>&lt;/div>&lt;p>####四、归并排序&lt;/p>&lt;p>归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用递归和分治法（Divide and Conquer）的一个非常典型的应用。&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>void merge(int *a,int start,int mid,int end)  {      if(start&amp;gt;mid || mid &amp;gt;end ) return;      int i=start,j=mid+1,k=0;      int *L=(int *)malloc((end-start+1)*sizeof(int));      while(i&amp;lt;=mid &amp;amp;&amp;amp; j&amp;lt;=end)      {        if(a[i]&amp;lt;a[j])          {              L[k++]=a[i++];          }          else          {              L[k++]=a[j++];          }      }        while(i&amp;lt;=mid)            L[k++]=a[i++];        while(j&amp;lt;=end)            L[k++]=a[j++];      for(i=start,j=0;i&amp;lt;=end;i++,j++)      {            a[i]=L[j];      }      free(L);  }  void mergeSort(int *a, int start,int end)  {    if(start&amp;lt;end)    {        int mid=(start+end)/2;        mergeSort(a,start,mid);        mergeSort(a,mid+1,end);        merge(a,start,mid,end);    }  }  &lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/MergeSort.png" alt="归并排序" />&lt;/p>&lt;p>####五、基数排序&lt;/p>&lt;p>基数排序(Radix sort)是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。&lt;/p>&lt;p>####快速排序与归并排序，冒泡排序与选择排序关系&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/relation.png" alt="排序之间关系" />&lt;/p></description>
<link>/%E7%AE%97%E6%B3%95/2014-07/Sort-Algorithm.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-07/Sort-Algorithm</guid>
<pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[linux下使用g++编译，gdb调试c++程序]]></title>
<description>&lt;h3 id="linux下编译调试c程序">linux下编译调试c++程序&lt;/h3>&lt;p>都说不会调试的程序员不是好程序员，今天终于通过看相关博客，进社区，动手实践三大步骤，把linux下编译和调试c++程序过了一遍。本文主要写linux下使用Vim编辑器写c++程序，然后通过g++编译器对程序进行编译，最后用gdb调试工具进行调速，命令行式的调试，有助于学习并熟知linux环境下c++/c编程操作。&lt;/p>&lt;!-- more -->&lt;p>一般来说，GCC主要帮忙你完成一下四方面的功能：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.预处理2.编译3.汇编4.连接&lt;/code>&lt;/pre>&lt;/div>&lt;p>特点：支持多语言，多系统&lt;/p>&lt;p>一般来说，GDB主要帮忙你完成下面四个方面的功能：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）3、当程序被停住时，可以检查此时你的程序中所发生的事。4、动态的改变你程序的执行环境。&lt;/code>&lt;/pre>&lt;/div>&lt;p>特点:命令行式的调试工具，非图形化操作&lt;/p>&lt;p>编译c/c++程序命令:&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>gcc -o demo demo.cg++ -g -o demo demo.cpp&lt;/code>&lt;/pre>&lt;/div>&lt;p>gdb基本命令列表：&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdb.png" alt="蔡金林的博客之GDB命令" />&lt;/p>&lt;p>以我在leetcode(https://oj.leetcode.com/)上面AC的一道题目”Reverse Words in a String”来分析：&lt;/p>&lt;p>1.使用vim编辑器编写c++程序&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Reverseclass.png" alt="蔡金林的博客之反转字符串并去掉多余空格类" />&lt;/p>&lt;p>主函数main:&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;string&amp;gt;int main(){     string inputstr;     getline(cin,inputstr);     Solution *s =  new Solution();     s-&amp;gt;reverseWords(inputstr);     delete s;     cout&amp;lt;&amp;lt;inputstr&amp;lt;&amp;lt;endl;}&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.gcc编译,生成可执行文件,注意必须使用-g参数，编译会加入调试信息否则无法执行文件&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>g++ -g -o demo demo.cpp&lt;/code>&lt;/pre>&lt;/div>&lt;p>3.gdb调试&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdbstart.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.1查看源文件 list 1,回车，直到显示完整程序&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdblist.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.2设置断点 break 8,在第8行设置断点，info break查看断点信息&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdbbreak.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.3调试运行 输入run 或者r&lt;/p>&lt;p>进行程序的输入&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>   the sky is   blue &lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdbrun.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.4单步调试，输入step 或者 s进入函数内部&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdbstep.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.5查看变量 输入print 变量 或者 p 变量&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdbprint.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.6继续运行直到下一个断点或主函数结束 输入continue或者 c&lt;/p>&lt;p>程序结果&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>blue is sky the&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/gdbcontinue.png" alt="蔡金林的博客" />&lt;/p>&lt;p>3.7 退出调试 输入q&lt;/p></description>
<link>/linux/2014-07/linux-gdb.html</link>
<guid>/linux/2014-07/linux-gdb</guid>
<pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[使用SVN部署网站到新浪SAE]]></title>
<description>&lt;h3 id="使用svn部署代码到sae平台">使用SVN部署代码到SAE平台&lt;/h3>&lt;p>最近3天在新浪SAE平台上部署了一个网站应用http://susecst.sinaapp.com/ ，本文主要写上传到SAE上面所遇到的问题。本地调试好代码后，通过svn上传http://sae.sina.com.cn/doc/tutorial/code-deploy.html#svn&lt;/p>&lt;!-- more -->&lt;p>####数据库连接语句配置&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>数据库服务器:w.rdc.sae.sina.com.cn:3307(在phpyadmin管理界面可见)数据库用户:应用首页的Access Key（点击显示可见）数据库密码:应用首页的Secret Key(点击显示可见)数据库名字:一般为app_应用名(数据库.sql文件需导入phpmyadmin)&lt;/code>&lt;/pre>&lt;/div>&lt;p>####上传至新浪SAE后，发现文件乱码&lt;/p>&lt;p>避免文件乱码，首先要确定以下四种编码一致,假设为utf8&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>数据库中表的结构编码utf8_general_ci文件编码&amp;lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&amp;gt;数据库执行语句编码 mysql_query(“set names utf8”);&lt;/code>&lt;/pre>&lt;/div>&lt;p>有的时候得确认下文件编码:通过编辑器控制文件的标题编码，或者将文件另存为你需要的文件编码utf8。&lt;/p>&lt;p>####测试功能时，发现登录界面提交后显示&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Cannot send session cache limiter-headers aleady sent&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/session.png" alt="跳转错误" />&lt;/p>&lt;p>搜索一番，发现基本是使用header跳转之前，不能出现任何echo语句，但是本地打开发现没有任何错误。最后在sae的代码管理器打开，发现了该文件前面有个小红点，删掉就行了，然后本地update，保持同服务器端版本一致&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/sae.png" alt="文件前面小红点" />&lt;/p></description>
<link>/php/2014-06/php-svn.html</link>
<guid>/php/2014-06/php-svn</guid>
<pubDate>Tue, 24 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[PHP实现多线程抓取网页]]></title>
<description>&lt;h3 id="php实现多线程抓取网页">PHP实现多线程抓取网页&lt;/h3>&lt;p>使用PHP的cURL库可以简单和有效地去抓网页。你只需要运行一个脚本，然后分析一下你所抓取的网页，然后就可以以程序的方式得到你想要的数据了。无论是你想从从一个链接上取部分数据，或是取一个XML文件并把其导入数据库，那怕就是简单的获取网页内容，cURL 是一个功能强大的PHP库。本文主要讲述如果使用这个PHP库抓取网页。&lt;/p>&lt;!-- more -->&lt;p>####开启curl库&lt;/p>&lt;p>首先要确定我们的PHP是否开启了这个库，如果你是在Windows平台下，需要改一改你的php.ini文件的设置，找到php_curl.dll，取消前面的分号就行：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>extension=php_curl.dll&lt;/code>&lt;/pre>&lt;/div>&lt;p>#####利用curl抓取网页代码&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&amp;lt;?php$urls = array(        'http://www.baidu.com/',    'http://www.caijinlin.com/',    'http://caijinlin.github.io');   $save_to='./res.txt';   // 把抓取的代码写入该文件       $st = fopen($save_to,"a");      $mh = curl_multi_init(); //创建多个curl句柄foreach ($urls as $i =&amp;gt; $url) {   $conn[$i] = curl_init($url);   //创建一个curl句柄curl_setopt($conn[$i], CURLOPT_USERAGENT, "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)");   curl_setopt($conn[$i], CURLOPT_HEADER ,0);  // 这里不要header，加块效率curl_setopt($conn[$i], CURLOPT_CONNECTTIMEOUT,60);   //设置超时时间curl_setopt($conn[$i],CURLOPT_RETURNTRANSFER,true);  // 设置不将爬取代码写到浏览器，而是转化为字符串  curl_multi_add_handle ($mh,$conn[$i]);   //向curl批处理会话中添加单独的curl句柄}   do {       curl_multi_exec($mh,$active);//循环执行   } while ($active);   foreach ($urls as $i =&amp;gt; $url) {       $data = curl_multi_getcontent($conn[$i]); // 获得爬取的代码字符串       fwrite($st,$data);  // 将字符串写入文件。当然，也可以不写入文件，比如存入数据库   } // 获得数据变量，并写入文件   foreach ($urls as $i =&amp;gt; $url) {     curl_multi_remove_handle($mh,$conn[$i]); // 移除curl批处理句柄资源中的某个句柄资源    curl_close($conn[$i]);   }    curl_multi_close($mh); //关闭多个cURL 多个句柄fclose($st);  //关闭文件?&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>####效果预览&lt;/p>&lt;p>抓取3个网页，通过curl可以达到多线程，进行同时抓取，而不必等到第一个网页抓取完毕，再抓取第二个。res.txt文件中，存放了3个网页的代码，分别复制出来，存放在html文件中，就可以看到他们的效果如下。&lt;/p>&lt;p>百度页面&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/baidu.png" alt="邻接表" />&lt;/p>&lt;p>我的基于jekyllbootstrap的博客&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/jekyllblog.png" alt="邻接表" />&lt;/p>&lt;p>我的wordpress博客&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/wordpress.png" alt="邻接表" />&lt;/p></description>
<link>/php/2014-06/php-craw.html</link>
<guid>/php/2014-06/php-craw</guid>
<pubDate>Mon, 23 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[php+shell实现多线程demo]]></title>
<description>&lt;p>###linux下借助shell实现php多线程&lt;/p>&lt;p>在一个程序中，这些独立运行的程序片段叫作多线程，利用它编程的概念叫做“多线程处理”。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，进而提升处理性能。php本身不支持多线程，但apache和linux支持多线程。本文主要讲在linux环境下，借助shell脚本实现php多线程。&lt;/p>&lt;!-- more -->&lt;p>写个简单的demo,源文件test.php&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&amp;lt;?phpfor($i = 0;$i &amp;lt; 10;$i++){   echo $i;   sleep(5);//相当于定时器}?&amp;gt;&lt;/code>&lt;/pre>&lt;/div>&lt;p>shell脚本文件thread&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>&lt;span class="c">#!/bin/bash&lt;/span>&lt;span class="k">for &lt;/span>i &lt;span class="k">in &lt;/span>1 2 3 4 5 6 7 8 9 10&lt;span class="k">do&lt;/span>    /usr/bin/php -q /var/www/test.php &amp;amp;&lt;span class="k">done&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行shell脚本命令&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>sh thread&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出效果&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/thread.png" alt="蔡金林的博客之php多线程" />&lt;/p>&lt;p>可以看到有10个进程同时在进行，定时请求这个shell，在shell的循环中不必每次等php的代码全部执行完再请求下一个文件，而是同时进行。&lt;/p></description>
<link>/linux/2014-06/linux-thread.html</link>
<guid>/linux/2014-06/linux-thread</guid>
<pubDate>Sun, 22 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[图论之最短路算法]]></title>
<description>&lt;h3 id="dijkstra算法">Dijkstra算法&lt;/h3>&lt;p>Dijkstra算法解决了有向加权图的最短路径问题，该算法的条件是该图所有边的权值非负，对于每条边(u,v) E，w(u,v)&amp;gt;=0。Dijkstra算法中设置了一结点集合S，从源结点s到集合S中结点的最终最短路径的权均已确定，即对所有结点v S，有d[v]= (s,v)。算法反复挑选出其最短路径估计为最小的结点u V-S，把u插入集合S中，并对离开u的所有边进行松弛。在下列算法实现中设置了优先队列Q，该队列包含所有属于V-S的结点，且队列中各结点都有相应的d值。Dijkstra算法如图所示对边进行松弛操作，最左结点为源结点，每个结点内为其最短路径估计。&lt;/p>&lt;!-- more -->&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Djs.png" alt="邻接表" />&lt;/p>&lt;p>因为Dijkstra算法总是在集合V-S中选择“最轻”或“最近”的结点插入集合S中，因此我们说它使用了贪心策略。需要指出的是，贪心策略并非总能获得全局意义上的最理想结果。但Dijkstra算法确实计算出了最短路径。&lt;/p>&lt;h3 id="bellmanford算法">Bellman—Ford算法&lt;/h3>&lt;p>Bellman-Ford算法能在更一般的情况下解决单源点最短路径问题，在该算法下边的权可以为负。正如Dijkstra算法一样，Bellman-Ford算法运用了松弛技术，对每一结点vV，逐步减小从源s到v的最短路径的估计值d[v]直至其达到实际最短路径的权(s,v)，如果图中存在负权回路，算法将会报告最短路不存在。&lt;/p>&lt;table>  &lt;tbody>    &lt;tr>      &lt;td>源结点为z。每个结点内为该结点的d值，阴影覆盖的边说明了值。在该实例中，Bellman-Ford算法返回TRUE。在进行了通常的初始化后，算法对图的边执行&lt;/td>      &lt;td>V&lt;/td>      &lt;td>-1次操作。每次均为第2-4行For循环的一次迭代，在迭代过程中对图的每条边松弛一次，图(b)-(c)说明了全部四次操作的每一次后算法的状态,在进行完&lt;/td>      &lt;td>V&lt;/td>      &lt;td>-1次操作后,算法5-8行检查是否存在负权的回路并返回正确的布尔值。&lt;/td>    &lt;/tr>  &lt;/tbody>&lt;/table>&lt;table>  &lt;tbody>    &lt;tr>      &lt;td>Bellman-Ford算法的运行时间为O(VE)。因为第1行的初始化占用时间为O(V)，第2-4行对边进行的&lt;/td>      &lt;td>V&lt;/td>      &lt;td>-1次操作的每一次运行时间为O(E)，第5-7行的For循环的运行时间为O(E)。&lt;/td>    &lt;/tr>  &lt;/tbody>&lt;/table>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Ford.png" alt="邻接表" />&lt;/p>&lt;p>Bellman-Ford算法的思想基于以下事实：“两点间如果有最短路，那么每个结点最多经过一次。也就是说，这条路不超过n-1条边。”（如果一个结点经过了两次，那么我们走了一个圈。如果这个圈的权为正，显然不划算；如果是负圈，那么最短路不存在；如果是零圈，去掉不影响最优值）&lt;/p>&lt;h3 id="spfa算法">SPFA算法&lt;/h3>&lt;p>求单源最短路的SPFA算法的全称是：Shortest Path Faster Algorithm。从名字我们就可以看出，这种算法在效率上一定有过人之处。&lt;/p>&lt;p>很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。&lt;/p>&lt;p>简洁起见，我们约定有向加权图G不存在负权回路，即最短路径一定存在。当然，我们可以在执行该算法前做一次拓扑排序，以判断是否存在负权回路。&lt;/p>&lt;p>和上文一样，我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列为空。&lt;/p>&lt;h3 id="案例分析">案例分析&lt;/h3>&lt;table>  &lt;tbody>    &lt;tr>      &lt;td>畅通工程续 SPFA&lt;/td>      &lt;td> &lt;/td>      &lt;td>dijkstra&lt;/td>      &lt;td> &lt;/td>      &lt;td>floyd&lt;/td>    &lt;/tr>  &lt;/tbody>&lt;/table>&lt;p>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1874&lt;/p>&lt;p>Dijkstra算法实现c++代码&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include &amp;lt;iostream&amp;gt;#include&amp;lt;memory.h&amp;gt;using namespace std;#define MAX 200#define INF 1000000int map[MAX][MAX];int dist[MAX];int visit[MAX];int n,m;void dfs(int s){   int vexnum=s;    int i,j;    memset(visit,0,sizeof(visit));    dist[vexnum]=0;    visit[vexnum]=1;    for(i=0;i&amp;lt;n;i++)    {       for(j=0;j&amp;lt;n;j++)       {          if(!visit[j]&amp;amp;&amp;amp;dist[j]&amp;gt;(dist[vexnum]+map[vexnum][j]))          {             dist[j]=dist[vexnum]+map[vexnum][j];          }     }     int min=INF;     for(j=0;j&amp;lt;n;j++)     {         if(!visit[j]&amp;amp;&amp;amp;dist[j]&amp;lt;min)         {             min=dist[vexnum=j];         }     }     visit[vexnum]=1;   }}int main(){  int i,j;  int a,b,x;  int s,t;  while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m)  {    for(i=0;i&amp;lt;n;i++)    {        dist[i]=INF;        for(int j=0;j&amp;lt;n;j++)            map[i][j]=INF;    }    for(i=0;i&amp;lt;m;i++)    {        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;x;        if(map[a][b]&amp;gt;x)        {            map[a][b]=map[b][a]=x;        }    }    cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;t;    dfs(s);    if(dist[t]!=INF)    {        cout&amp;lt;&amp;lt;dist[t]&amp;lt;&amp;lt;endl;    }    else    {        cout&amp;lt;&amp;lt;"-1"&amp;lt;&amp;lt;endl;    } }return 0;}&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="案例分析wormholes">案例分析：Wormholes&lt;/h3>&lt;p>题目链接http://poj.org/problem?id=3259&lt;/p>&lt;p>SPFA算法+邻接表实现版本：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;iostream&amp;gt;#include&amp;lt;stdio.h&amp;gt;using namespace std;struct node{  int u,v,w;}edge[6000];int dis[505];int n,m,w,index;const int inf=0x7ffffff;void add(int u,int v,int c){    index++;    edge[index].u=u;    edge[index].v=v;    edge[index].w=c;}bool bellman(){  int u,v,w,i,j,flag;  for(i=1;i&amp;lt;=n;i++)  {      dis[i]=inf;  }  dis[1]=0;flag=0;  for(i=1;i&amp;lt;=n;i++)  {    for(j=1;j&amp;lt;=index;j++)    {        if(dis[edge[j].v]&amp;gt;dis[edge[j].u]+edge[j].w)        {          dis[edge[j].v]=dis[edge[j].u]+edge[j].w;        }   }  }  for(i=1;i&amp;lt;=index;i++)      if(dis[edge[i].v]&amp;gt;dis[edge[i].u]+edge[i].w) return true;  return false;  }int main(){    int i,j,t,u,v,c;    scanf("%d",&amp;amp;t);    while(t--)    {       scanf("%d%d%d",&amp;amp;n,&amp;amp;m,&amp;amp;w);      index=0;      for(i=0;i&amp;lt;m;i++)      {        scanf("%d%d%d",&amp;amp;u,&amp;amp;v,&amp;amp;c);        add(u,v,c);        add(v,u,c);      }      for(i=0;i&amp;lt;w;i++)      {        scanf("%d%d%d",&amp;amp;u,&amp;amp;v,&amp;amp;c);        add(u,v,-1*c);      }      if(bellman()) printf("YES\n");          else printf("NO\n");      }      return 0;}&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="spfa算法队列实现版本">SPFA算法+队列实现版本：&lt;/h3>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;cstdio&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;const int INF=9999999;const int MAXN=520;const int MAXM=5200;struct edge{  int to;  int val;  int next;}e[MAXM];int len,head[MAXN];int dis[MAXN];int n,m,w;bool SPFA(){    for(int i=1;i&amp;lt;=n;i++)    dis[i]=INF;    bool vis[MAXN]={0};    int cnt[MAXN]={0};    int cur=1;    queue&amp;lt;int&amp;gt; q;    q.push(cur);    vis[cur]=true;    cnt[cur]=1;    dis[cur]=0;    while(!q.empty())      {       cur=q.front();        q.pop();        vis[cur]=false;        for(int i=head[cur]  ;i!=-1; i=e[i].next)        {            int id=e[i].to;            if( dis[cur] + e[i].val &amp;lt; dis[ id ] )            {              dis[ id ] = dis[cur] + e[ i ].val;              if(!vis[id])              {                cnt[id]++;                vis[id]=true;                q.push(id);                if(cnt[cur]&amp;gt;n)                return true;              }            }        }    }    return false;}void add(int from,int to,int val){  e[len].to=to;  e[len].val=val;  e[len].next= head[from];  head[from]=len++;}int main(){  int T;  scanf("%d",&amp;amp;T);  while(T--)  {    memset(head,-1,sizeof(head));    len=0;    scanf("%d%d%d",&amp;amp;n,&amp;amp;m,&amp;amp;w);    for(int i=0;i&amp;lt;m;i++)    {      int from,to,val;      scanf("%d%d%d",&amp;amp;from,&amp;amp;to,&amp;amp;val);      add(from,to,val);      add(to,from,val); //双向的    }    for(int i=0;i&amp;lt;w;i++)    {      int from,to,val;      scanf("%d%d%d",&amp;amp;from,&amp;amp;to,&amp;amp;val);      add(from,to,-val);    }    if( SPFA())      puts("YES");    else      puts("NO");  }  return 0;}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-06/Graph-ShortestPath.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-06/Graph-ShortestPath</guid>
<pubDate>Sat, 21 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[图的遍历算法———BFS和DFS算法]]></title>
<description>&lt;h3 id="深度优先遍历和广度优先遍历">深度优先遍历和广度优先遍历&lt;/h3>&lt;p>从图的某顶点出发，访问图中所有顶点，并且每个顶点仅访问一次。图中可能有回路，遍历可能沿回路又回到已遍历过的结点。为避免同一顶点被多次访问，必须为每个被访问的顶点作一标志。为此引入一辅助数组,记录每个顶点是否被访问过。&lt;/p>&lt;!-- more -->&lt;p>####1.使用邻接表来储存图的节点关系&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Adjlist.png" alt="邻接表" />&lt;/p>&lt;p>####2. 深度优先遍历&lt;/p>&lt;p>思路:从图的某一顶点V0出发，访问此顶点；然后依次从V0的未被访问的邻接点出发，深度优先遍历图，直至图中所有和V0相通的顶点都被访问到；&lt;/p>&lt;p>若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Dft.png" alt="邻接表" />&lt;/p>&lt;p>####3.广度优先遍历&lt;/p>&lt;p>思路：从图中的某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到。&lt;/p>&lt;p>若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/Bft.png" alt="邻接表" />&lt;/p>&lt;p>####4.BFS和DFS算法实现c++版&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;memory.h&amp;gt;using namespace std;const int n=9;int visit[100];//访问标志void BFS(int a[][n] , int n) //宽度优先遍历{  queue&amp;lt;int&amp;gt; g;  int i;  memset(visit,0,sizeof(visit));  g.push(0);  cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;" ";  visit[0]=1;  while(!g.empty())  {     int vexnum=g.front();    g.pop();    for(i=0;i&amp;lt;n;i++)    {       if(a[vexnum][i]!=0&amp;amp;&amp;amp;!visit[i])       {           g.push(i);           visit[i]=1;//设置进栈标志           cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;" ";       }    }  }}void DFS(int a[][n], int v){    visit[v]=1;    cout&amp;lt;&amp;lt;v&amp;lt;&amp;lt;" ";    for(int i=0;i&amp;lt;n;i++)    {        if(a[v][i]!=0&amp;amp;&amp;amp;!visit[i])        {            DFS(a, i);        }    }}int main(int argc, char* argv[]){    //邻接矩阵9*9，节点0~8    int a[n][n]={    1,1,0,0,1,1,1,1,0,    1,1,0,1,0,0,1,1,1,    0,0,1,1,0,1,1,0,1,    0,1,1,1,1,1,1,0,0,    1,0,0,1,1,0,1,1,0,    1,0,1,1,0,1,1,1,1,    1,1,1,1,1,1,1,0,1,    1,1,0,0,1,1,0,1,1,    0,1,1,0,0,1,1,1,1};for(int i=0;i&amp;lt;n;i++){    cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;":";    for(int j=0;j&amp;lt;n;j++)    {        if(a[i][j]!=0&amp;amp;&amp;amp;i!=j)        {            cout&amp;lt;&amp;lt;j;        }    }    cout&amp;lt;&amp;lt;endl;}cout&amp;lt;&amp;lt;"广度优先遍历："&amp;lt;&amp;lt;endl;BFS(a,n);cout&amp;lt;&amp;lt;endl;memset(visit,0,sizeof(visit));cout&amp;lt;&amp;lt;"深度优先遍历："&amp;lt;&amp;lt;endl;DFS(a,0);return 0;}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-06/Graph-Traversal.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-06/Graph-Traversal</guid>
<pubDate>Fri, 20 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[我们眼中的计算机学院毕业生——男会修电脑，女会上淘宝？]]></title>
<description>&lt;h3 id="川理计算机学院毕业生">川理计算机学院毕业生&lt;/h3>&lt;p>长亭就在古道的旁边，那首曲子听起来太缠绵。大学过了三年而今要和你们说再见，上铺的被子都还没折叠，那个昨天的功课都还没做完。&lt;/p>&lt;p>食堂打的饭还是那么一点点，怎么还花掉我那六块6毛钱。曾经年少爱追梦，一心只想往前飞。&lt;/p>&lt;p>梦早已做完还要怎么飞，青春多少伤悲有留给谁,宿舍的窗外繁星点点,那熄灯后的故事都还没讲完。&lt;/p>&lt;!-- more -->&lt;p>我们眼中的计算机专业学生是这样的吗？&lt;/p>&lt;p>敲不完的代码一行又一行，改不完的bug一个又一个&lt;/p>&lt;p>比赛神马最喜欢，起早贪黑苦逼鸟&lt;/p>&lt;p>大口小苹果，无事看美女男会修电脑，女会上淘宝。&lt;/p>&lt;p>小k想说，他们并不是这样，他们可以更接地气，他们甚至希望这个世界，因为他们的存在，开始有了一点点的不一样。&lt;/p>&lt;p>分享四川理工计算机学院2014届毕业生采访视频《再见，同桌的你》&lt;/p>&lt;embed src="http://player.youku.com/player.php/sid/XNzI1Njg5MTc2/v.swf" allowfullscreen="true" quality="high" width="650" height="500" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" />&lt;p>&amp;lt;/embed&amp;gt;&lt;/p></description>
<link>/%E9%9A%8F%E7%AC%94/2014-06/Suse-Computer.html</link>
<guid>/%E9%9A%8F%E7%AC%94/2014-06/Suse-Computer</guid>
<pubDate>Thu, 19 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[高精度算法]]></title>
<description>&lt;h3 id="高精度算法包含精度计算乘法精度计算加法等">高精度算法（包含精度计算乘法、精度计算加法等）&lt;/h3>&lt;p>高数精度算法，属于处理大数字的数学计算方法。在一般的科学计算中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除，乘方，阶乘，开方等运算。对于非常庞大的数字无法在计算机中正常存储，于是，将这个数字拆开，拆成一位一位的，或者是四位四位的存储到一个数组中， 用一个数组去表示一个字，这样这个数字就被称谓是高精度数。高精度算法就是能处理高精度数各种运算的算法。&lt;/p>&lt;!-- more -->&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/precision.png" alt="蔡金林的博客之高精度算法" />&lt;/p>&lt;p>在acmer眼里看来，大数字之间的运算一般都会用字符串的形式来处理，例如大数求阶乘，乘法，加法等。&lt;/p>&lt;p>北电上一道关于高精度算法的算法题，题目链接&lt;a href="http://poj.org/problem?id=1001">http://poj.org/problem?id=1001&lt;/a>，用了一下午的时间开始搜集各方面code，发现大多数杂而乱，在绞尽脑汁后，自己动手写了个，终于一次性AC。源代码实现c++版：/&lt;em>注释的代码是为了记录某些值，进行排错&lt;/em>/&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;stdio.h&amp;gt;;using namespace std;string add(string a, string b)//参与运算的两个数字串{int i,j,k,up,x,y,z;string c;//存放相加结果的字符串i=a.length()-1;j=b.length()-1;up=0;//进位while(i&amp;gt;=0||j&amp;gt;=0){        if(i&amp;lt;0) x='0'; else x=a[i];        if(j&amp;lt;0) y='0'; else y=b[j];        z=x-'0'+y-'0';        if(up) z+=1;//上一位加法产生的进位        if(z&amp;gt;9)        {            up=1;            z%=10;        }        else        {            up=0;        }        c.push_back(z+'0');//压入字符串        i--;        j--;}if(up)//判断最高位产生的进位{     c.push_back('1');}reverse(c.begin(),c.end());//字符串反转return c;}string multiple(string a, string b)  //计算两高精度数乘积{int i, j,k;string result = "0";for(i = a.length() - 1; i &amp;gt;= 0; i--){    int remain = 0;    string str = "";    for(j = b.length() - 1; j &amp;gt;= 0; j--)    {        int tmp = (a[i] - '0') * (b[j] - '0') + remain;        remain = tmp / 10;        str = (char)(tmp % 10 + '0') + str;    }    if(remain != 0)    {        str = (char)(remain + '0') + str;    }    for(k=i;k&amp;amp;lt;a.length()-1;k++)    {        str=str+'0';    }   result=add(str,result);}return result;}int main(){string s1,s2;int i,n,pos,j=0;string res="1";string::iterator its;char ch1[81];while(scanf("%s %d",ch1,&amp;amp;amp;n)!=EOF){    s1=ch1;    i=0;    pos=0;    for(its=s1.begin();its!=s1.end();its++)    {        if(*its=='.') //如果包含小数点，删除小数点，当作整数处理        {            pos=i;            s1.erase(its);            break;        }        i++;    }    /*    for(i=0;i&amp;lt;s1.size();i++)    {        cout&amp;lt;&amp;lt;s1[i];    }    cout&amp;lt;&amp;lt;endl;    */    for(i=1;i&amp;lt;=n;i++)//循环作乘法    {        res=multiple(s1,res);    }    if(pos!=0)//判断是否包含小数点    {          j=s1.size()-pos;//取得小数点后面数的个数          j=j*n;//输出时将要移动的小数点位数    }    /*    cout&amp;lt;&amp;lt;"j:"&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;    cout&amp;lt;&amp;lt;"res:";    for(i=0;i&amp;lt;res.size();i++)    {         cout&amp;lt;&amp;lt;res[i];    }    cout&amp;lt;&amp;lt;endl;    */   string::iterator it=res.begin();   if(pos!=0)   {        res.insert(it+res.size()-j,'.');        it=res.begin();        if(res[0]=='0'&amp;amp;&amp;amp; res[1]=='.') //删除0.0001中的小树点前面的0        {            res.erase(it);        }        while(res[res.size()-1]=='0') //删除0.5000中小数点后面的0        {            it=res.begin()+res.size()-1;            res.erase(it);        }        if(res[res.size()-1]=='.')//如果为整数，去掉小数点        {            it=res.begin()+res.size()-1;            res.erase(it);        }   }    for(i=0;i&amp;lt;res.size();i++)//直接输出    {        printf("%c",res[i]);    }    cout&amp;lt;&amp;lt;endl;    s1.clear();    res="1";}}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-06/Algorithm-Precision.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-06/Algorithm-Precision</guid>
<pubDate>Wed, 18 Jun 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[动态规划算法]]></title>
<description>&lt;p>###动态规划算法(拒绝暴力，提倡和谐）&lt;/p>&lt;p>动态算法: 自顶向下的分析，自底向上的计算，每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。似解。&lt;/p>&lt;!-- more -->&lt;p>####基本思想与策略&lt;/p>&lt;p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。&lt;/p>&lt;p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。&lt;/p>&lt;p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解&lt;/p>&lt;p>####适用的情况&lt;/p>&lt;p>能采用动态规划求解的问题的一般要具有3个性质&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。&lt;/code>&lt;/pre>&lt;/div>&lt;p>####动态规划算法的基本步骤&lt;/p>&lt;p>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。&lt;/p>&lt;p>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。&lt;/p>&lt;p>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。&lt;/p>&lt;p>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。&lt;/p>&lt;p>实际应用中可以按以下几个简化的步骤进行设计：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/backpack.png" alt="背包问题" />&lt;/p>&lt;p>####算法实现说明&lt;/p>&lt;p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。&lt;/p>&lt;p>使用动态规划求解问题，最重要的就是确定动态规划三要素：&lt;/p>&lt;p>（1）问题的阶段  （2）每个阶段的状态  （3）从前一个阶段转化到后一个阶段之间的递推关系。&lt;/p>&lt;p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。&lt;/p>&lt;p>具体分析http://acm.hdu.edu.cn/showproblem.php?pid=1159&lt;/p>&lt;p>####案例分析:Common Subsequence(最长公共子序列问题)&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/path.png" alt="动态规划路径" />&lt;/p>&lt;p>####算法实现code&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;stdio.h&amp;gt;#define Max 100using namespace std;int size(char *s){  int len=0;  while(*s!='\0')  {     len++;     s=s+1;  }  return len;}int main(int argc, char* argv[]){  int i,j;  int len1,len2;  int matricx[Max][Max];  char s1[80],s2[80];  while(scanf("%s %s",s1,s2) != EOF)  {    len1=size(s1);    len2=size(s2);    for(i=0;i&amp;lt;=len2;i++)    {      matricx[i][0]=0;    }    for(i=0;i&amp;lt;=len1;i++)    {        matricx[i][0]=0;    }    for(i=1;i&amp;lt;=len1;i++)    {      for(j=1;j&amp;lt;=len2;j++)      {          if(s1[i-1]==s2[j-1])          {              matricx[i][j]=matricx[i-1][j-1]+1;          }          else          {              matricx[i][j]=(matricx[i-1][j]&amp;gt;matricx[i][j-1])?matricx[i-1][j]:matricx[i][j-1];          }      }    }    cout&amp;lt;&amp;lt;matricx[len1][len2]&amp;lt;&amp;lt;endl;  }}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-05/Algorithm-dynamic.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-05/Algorithm-dynamic</guid>
<pubDate>Mon, 12 May 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[最小生成树]]></title>
<description>&lt;p>###图论之最小生成树(Prim算法和Kruskal算法)&lt;/p>&lt;p>所有顶点均由边连接在一起，但不存在回路的图叫生成树,在一给定的无向图G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集（即）且为无循环图，使得的 w(T) 最小，则此 T 为 G 的最小生成树。最小生成树其实是最小权重生成树的简称&lt;/p>&lt;!-- more -->&lt;p>####生成树的遍历方式&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>深度优先生成树广度优先生成树&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/tree.png" alt="生成树的遍历方式" />&lt;/p>&lt;p>####生成树的特点&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>生成树的顶点个数与图的顶点个数相同生成树是图的极小连通子图一个有n个顶点的连通图的生成树有n-1条边生成树中任意两个顶点间的路径是唯一的在生成树中再加一条边必然形成回路&lt;/code>&lt;/pre>&lt;/div>&lt;p>####构造最小生成树的方法&lt;/p>&lt;p>#####prim算法基本思想&lt;/p>&lt;p>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 个顶点为止。&lt;/p>&lt;p>一般情况下所添加的顶点应满足下列条件:&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>在生成树的构造过程中，图中 n 个顶点分属两个集合已落在生成树上的顶点集 U 和尚未落在生成树上的顶点集V-U ，则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。&lt;/code>&lt;/pre>&lt;/div>&lt;p>#####prim方法实现过程原理图&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/prim.png" alt="prim算法原理图" />&lt;/p>&lt;p>#####prim算法描述&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>Prim(Mgraph G, VexsType v0){ // v0－初始出发点，T－生成对中边的集合// U－生成树中顶点的集合T=ΦU={v0}while(U&amp;lt;&amp;gt;V){    求u,v,使得 c(u,v)最小，u €U, v €V-U    T=TU{(u,v)}    U=UU{v}}｝&lt;/code>&lt;/pre>&lt;/div>&lt;p>#####kruskal算法基本思想&lt;/p>&lt;p>具体做法：&lt;/p>&lt;p>先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止考虑问题的出发点：&lt;/p>&lt;p>为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能地小&lt;/p>&lt;p>#####kruskal算法实现过程原理图&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/kruskal.png" alt="kruskal算法原理图" />&lt;/p>&lt;p>####prim和Kruskal算法具体实现c++版(官方)&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;cstdio&amp;gt;#define MAX_VERTEX_NUM 20 //保存节点个数#define OK 1#define ERROR 0#define MAX 1000using namespace std;typedef struct Arcell//保存邻接矩阵{double adj;//边的权值}Arcell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct MGraph{char vexs[MAX_VERTEX_NUM];//节点数组AdjMatrix arcs;//邻接矩阵int vexnum,arcnum;//图的节点个数和边或弧数}MGraph;typedef struct Pnode//用于普利姆prim算法{char adjvex;//节点double lowcost;//权值}Pnode,Closedge[MAX_VERTEX_NUM];//记录顶点集U到V-U的代价最小的边的辅助数组定义typedef struct Knode//用于克鲁斯卡尔算法中存储一条边及其对应的2个节点{char ch1;//节点1char ch2;//节点2double value;//权值}Knode,Dgevalue[MAX_VERTEX_NUM];//-------------------------------------------------------------------------------int CreateUDG(MGraph &amp;amp;G,Dgevalue &amp;amp;dgevalue);int LocateVex(MGraph G,char ch);int Minimum(MGraph G,Closedge closedge);void MiniSpanTree_PRIM(MGraph G,char u);void Sortdge(Dgevalue &amp;amp;dgevalue,MGraph G);//-------------------------------------------------------------------------------int CreateUDG(MGraph &amp;amp;G,Dgevalue &amp;amp;dgevalue)//构造无向加权图的邻接矩阵{int i,j,k;cout&amp;lt;&amp;lt;"请输入图中节点个数和边/弧的条数："; cin&amp;gt;&amp;gt;G.vexnum&amp;gt;&amp;gt;G.arcnum;cout&amp;lt;&amp;gt;G.vexs[i];for(i=0;i&amp;lt;G.vexnum;++i)//初始化数组{for(j=0;j&amp;gt;dgevalue[k].ch1&amp;gt;&amp;gt;dgevalue[k].ch2&amp;gt;&amp;gt;dgevalue[k].value;i=LocateVex(G,dgevalue[k].ch1);j=LocateVex(G,dgevalue[k].ch2);G.arcs[i][j].adj=dgevalue[k].value;G.arcs[j][i].adj=G.arcs[i][j].adj;}return OK;}int LocateVex(MGraph G,char ch)//确定节点ch在图G.vexs中的位置{int a;for(int i=0;idgevalue[j].value){temp=dgevalue[i].value;dgevalue[i].value=dgevalue[j].value;dgevalue[j].value=temp;ch1=dgevalue[i].ch1;dgevalue[i].ch1=dgevalue[j].ch1;dgevalue[j].ch1=ch1;ch2=dgevalue[i].ch2;dgevalue[i].ch2=dgevalue[j].ch2;dgevalue[j].ch2=ch2;}}}}int main(){int i,j;MGraph G;char u;Dgevalue dgevalue;CreateUDG(G,dgevalue);cout&amp;lt;&amp;lt;"图的邻接矩阵为："&amp;lt;&amp;lt;endl;for(i=0;i&amp;lt;G.vexnum;i++){for(j=0;j&amp;lt;&amp;amp;G.vexnum;j++)cout&amp;lt;&amp;lt;G.arcs[i][j].adj&amp;lt;&amp;lt;"   ";cout&amp;lt;&amp;lt;endl;}cout&amp;lt;&amp;lt;"=============普利姆Prim算法===============\n";cout&amp;lt;&amp;lt;"请输入起始点：";cin&amp;gt;&amp;gt;u;cout&amp;lt;&amp;lt;"构成最小代价生成树的边集为：\n";MiniSpanTree_PRIM(G,u);cout&amp;lt;&amp;lt;"============克鲁斯科尔Kruskal算法=============\n";cout&amp;lt;&amp;lt;"构成最小代价生成树的边集为：\n";MiniSpanTree_KRSL(G,dgevalue);return 0;}&lt;/code>&lt;/pre>&lt;/div>&lt;p>####案例分析:：Constructing Roads&lt;/p>&lt;p>题目链接：http://poj.org/problem?id=2421&lt;/p>&lt;p>算法思想：运用prim方法构造最小生成树&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;#define INF 0xffffffint arics[105][105];int visit[105],dis[105],sum,n;void prim(){	memset(visit,0,sizeof(visit));	int i,j;	for(i=1;i&amp;lt;=n;i++)	{	    dis[i]=arics[1][i];	}    visit[1]=1;	for(i=1;i&amp;lt;=n;i++)	{	    int temp=INF;	    int k;//记录最小边的顶点序号	    for(j=1;j&amp;lt;=n;j++)	    {	        if((!visit[j])&amp;amp;&amp;amp;(temp&amp;gt;dis[j]))	        {                temp=dis[j];                k=j;	        }	    }	    if(temp==INF)	    {	        break;	    }	    visit[k]=1;//置为已访问标志	    sum+=dis[k];	    for(j=1;j&amp;lt;=n;j++)	    {	        if(!visit[j])	        {	            if(dis[j]&amp;gt;arics[k][j])	            {	                dis[j]=arics[k][j];//更新值	            }	        }	    }	}}int main(){    int i,j,a,b,q;    cin&amp;gt;&amp;gt;n;//输入节点个数    for(i=1;i&amp;lt;=n;i++) //输入带权邻接矩阵    {        for(j=1;j&amp;lt;=n;j++)        {            cin&amp;gt;&amp;gt;arics[i][j];        }    }    cin&amp;gt;&amp;gt;q;//已经建了公路的个数    for(i=1;i&amp;lt;=q;i++)    {         cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;//输入公路的两端（节点）         arics[a][b]=arics[b][a]=0;    }    sum=0;    prim();    cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;    return 0;}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-05/Algorithm-tree.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-05/Algorithm-tree</guid>
<pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate>
</item>
<item>
<title><![CDATA[贪心算法]]></title>
<description>&lt;p>###贪心算法（自顶向下，局部最优）&lt;/p>&lt;p>贪心算法（又称贪婪算法）：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。&lt;/p>&lt;!-- more -->&lt;p>####贪心算法的基本思想&lt;/p>&lt;p>找出整体当中每个小的局部的最优解，并且将所有的这些局部最优解合起来形成整体上的一个最优解。&lt;/p>&lt;p>####贪心选择性质&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1.整体的最优解可以通过局部的最优解来求出；2.一个整体能够被分为多个局部，并且这些局部都能够求出最优解。&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用贪心算法当中的两个典型问题是活动安排问题和背包问题。&lt;/p>&lt;p>####贪心算法的基本步骤&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>1、从问题的某个初始解出发。2、采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。3、将所有部分解综合起来，得到问题的最终解。&lt;/code>&lt;/pre>&lt;/div>&lt;p>####经典案例:活动安排问题,背包等&lt;/p>&lt;p>&lt;img src="http://7xirhj.com1.z0.glb.clouddn.com/blog/assert/images/backpack.png" alt="背包问题" />&lt;/p>&lt;p>####案例分析:平衡负载&lt;/p>&lt;p>2013年百度之星区域赛中的第一题”平衡负载”，主要就利用贪心进行分段，在我们理工的acm平台上有这道题，闲着也是闲着，贴出这道题自己的c++版本code。&lt;/p>&lt;p>平衡负载&lt;/p>&lt;p>Du熊正在负责一个大型的项目，目前有K台服务器，有N个任务需要用这K台服务器来完成，所以要把这些任务分成K个部分来完成，在同上台服务器上执行的任务必须是连续的任务，每个任务有各自需要的执行时间。例如N=5,K=2，每个任务需要时间分别为5,3,1,4,7分钟，那么我们可以分成(5)(3 1 4 7)两部分，这样第一台服务器所花时间就是5分钟，而第二台机器需要花15分钟，当然，所有任务完成的时间是按最迟完成的那台服务器的时间，即这样划分的话完成所有任务所需要的时间就是15分钟。而另外一种划分方法是(5 3 1)(4 7)，这种划分方案完成所有任务的时间就是11分钟，也是最优的一种划分方案。现在你的任务就是根据给定的N,K和每个任务要花费的时间，找出使完成所有任务时间最短的方案。&lt;/p>&lt;p>输入：多组输入。&lt;/p>&lt;p>第一行输入N和K（1&amp;lt;=K&amp;lt;=N&amp;lt;=10000）。&lt;/p>&lt;p>第二行输入N个不大于1000的正整数，表示各个任要花费的时间。N=K=0表示输入结束。&lt;/p>&lt;p>输出：&lt;/p>&lt;p>每行输出一个整数，对应对于每个数据（除了N=K=0不用输出）。&lt;/p>&lt;p>样例输入：&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>5 15 3 1 4 75 25 3 1 4 75 3&lt;/code>&lt;/pre>&lt;/div>&lt;p>####算法实现code&lt;/p>&lt;div class="highlighter-rouge">&lt;pre class="highlight">&lt;code>#include&amp;lt;stdio.h&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int a[10005];bool check(int a[], int k,int m, int n) //数组，分k段,用来分段的m值,数组个数（检测m值是否可以将数组分为k段）{    int i,sum=0,count=0;    for(i=0;i&amp;lt;n;i++)    {        sum+=a[i];//前i项求和        if(sum&amp;gt;m) //若超过m值，则前i-1项分为一段,重新寻求下一段，同时段数加1        {            sum=a[i];            count++;        }    }    count++;//加上最后一段    return count&amp;lt;=k;}int main(){    int i=0,j=0,n,k,l,r,mid=0;    while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k&amp;amp;&amp;amp;n!=0&amp;amp;&amp;amp;k!=0)    {       l=0;//最左边       r=0;//最右边       for(i=0;i&amp;lt;n;i++)       {           cin&amp;gt;&amp;gt;a[i];           r+=a[i];       }       while(l&amp;lt;r)       {           mid=(l+r)/2;           if(check(a,k,mid,n)) //m值分段数小于k，则要分段的m值应该减少，承受的项的个数更少，段数增加           {              r=mid;           }           else //m值分段数大于k，则要分段的m值应该增加，可承受更多项的和，段数减少           {              l=mid+1;           }       }       printf("%d\n",l);//输出时间    }    return 0;}&lt;/code>&lt;/pre>&lt;/div></description>
<link>/%E7%AE%97%E6%B3%95/2014-05/Algorithm-greedy.html</link>
<guid>/%E7%AE%97%E6%B3%95/2014-05/Algorithm-greedy</guid>
<pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate>
</item>
</channel>
</rss>